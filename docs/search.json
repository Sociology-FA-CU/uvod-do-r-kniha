[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Úvod do analýzy dat v R",
    "section": "",
    "text": "Předmluva\nUčit se R je běh na dlouhou trať. Je to cesta, která znamená mnohem větší časovou investici než zvládnutí softwaru s GUI, jako je například SPSS. Odměnou je mnohem větší flexibilita a v ruce univerzální nástroj pro zpracování dat, analýzu, vizualizaci, ale i programování a automatizaci. R je každý den využíváno nespočetným množstvím studentů, výzkumníků a dalších odborníků pro analýzu dat, ale i vytváření webových stránek a aplikací nebo psaní knih (včetně této!). Jak bylo kdysi proneseno na dnes již zapomenutém kousku internetu:\n\nEvelyn Hall: I would like to know how (if) I can extract some of the information from the summary of my nlme.\nSimon Blomberg: This is R. There is no if. Only how.\n—Evelyn Hall and Simon ‘Yoda’ Blomberg, R-help (April 2005)\n\nTento text je průvodcem pro návštěvníky poprvé vstupující do světa R, který je provede základy datové analýzy od instalace všeho nezbytného softwaru, až po manipulaci a vizualizaci dat. Slouží zároveň jako podklad pro výuku kurzu Úvod do analýzy dat v R na katedře sociologie FF Univerzity Karlovy. Vznik tohoto textu byl podpořen NMS Market Research.\nTato kniha je licencovaná pod Creative Commons Attribution-NonCommercial 2.0 Generic a je možné ji volně šířit pro nekomerční účely."
  },
  {
    "objectID": "predstaveni.html#r",
    "href": "predstaveni.html#r",
    "title": "R, Rstudio, Tidyverse",
    "section": "R",
    "text": "R\nR je volně šiřitelný, otevřený programovací jazyk zaměřený specificky na vizualizaci a statistickou analýzu dat. Jeho počátky sahají do poloviny 90. let minulého století, kdy začal být vytvářen dvěma pracovníky Aucklandské university, Rossem Ihakem a Robertem Gentlemanem. Od té doby se stal stal jedním z nejpopulárnějších jazyků pro analýzu dat a drží se mezi nejpopulárnějšími jazyky vůbec. R je široce využívané jak pro akademický výzkum, tak v komerční i veřejné sféře.\nZatímco funkčnost jiných statistické programů, jako například SPSS nebo Excel, je omezená na autory před-připravené nástroje a postupy, možnosti R jsou téměř neomezené. Kromě základních i pokročilých statistických analýz je možné R využít k psaní knih, článků, internetových stránek (včetně této) nebo webových aplikací. R je také využíváno řadou předních statistiků, jejichž práce se týká i sociálněvědního výzkumu.\n\n\n\n\n\n\nČeská stopa v R\n\n\n\nPřestože jeho počátky sahají na Nový Zéland, do historie R se významně zapsalo i několik rodáků z Česka. Jedním ze současných členů hlavního vývojářského týmu je Šimon Urbánek, který se mimo jiné zasloužil o vytvoření R verze pro MacOS. Verzi pro Windows, a nejen ji, spravuje druhý český člen týmu, Tomáš Kalibera. Neobyčejně velkou měrou přispěl k rozvoji R i Jan Vítek.\n\n\nCenou za široké možnosti R jsou vyšší nároky na jeho osvojení, jelikož na rozdíl od programů s grafickým rozhraním vyžaduje práce s R alespoň základní znalosti programování. Naštěstí již dnes existuje řada zdrojů a komunit, které mohou s tímto problémem pomoci. Pro inspiraci můžeme zmínit blog R-bloggers, skupinu Rladies nebo komunitní projekt Tidytuesday."
  },
  {
    "objectID": "predstaveni.html#rstudio",
    "href": "predstaveni.html#rstudio",
    "title": "R, Rstudio, Tidyverse",
    "section": "Rstudio",
    "text": "Rstudio\nDávno už jsou pryč časy, kdy práce s programovacími jazyky znamenala psaní kódu v jednoduché příkazové řádce (nebo nedej bože prorážení dírkovacích štítků!). Dnešní uživatelé mohou využívat sofistikovaných programů, jejich cílem je usnadnit každodenní práci. Těmto programům se říká integrované vývojářské prostředí (Integrated Development Environments) a jasně nejpopulárnějším IDE pro R je v současné době Rstudio.\nRstudio, vyvíjené stejnojmennou společností, bude kontrolovat váš kód, napovídat vám jména funkcí, exportovat grafy a mnoho dalšího. Nejedná se samozřejmě o jediné vývojářským prostředí pro R (konkurenty jsou například VScode, Vim nebo ESS Emacs), představuje však výbornou rovnováhu mezi výkonem a uživatelskou přívětivostí a skvělou volbou pro všechny nováčky."
  },
  {
    "objectID": "predstaveni.html#tidyverse",
    "href": "predstaveni.html#tidyverse",
    "title": "R, Rstudio, Tidyverse",
    "section": "Tidyverse",
    "text": "Tidyverse\nPřestože jsou možnosti R nesmírně široké, zdaleka ne všechny nástroje vám budou k dispozici hned po jeho instalaci. Většina rozšíření pro R je distribuovaná formou balíčků (packages), které jsou volně dostupné ke stažení.\nBalíčků, které do R přináší nové funkce, dnes existují desítky tisíc. Jednou z nejpopulárnějších rodin takových balíčků je Tidyverse, která rozšiřuje možnosti R zejména v oblastech manipulace a vizualizace dat. Mnoho úkonů, které se v základním R provádí velmi zdlouhavě nebo krkolomně, jsou v Tidyverse záležitostí na jeden dva řádky. Jednotlivé balíčky jsou také designovány tak, aby si spolu navzájem rozuměli a využívali identickou syntax. Stinnou stránkou živelné popularity R je, že řada jeho vývojářů má značně rozdílné představy o psání počítačového kódu. To vede k mnoha různým konvencím, které jsou pro běžného uživatele matoucí (např. mají funkce začínat velkým, nebo malým písmenem? mají se slova oddělovat potržítkem, nebo tečkou?). Všechny balíčky Tidyverse se drží jednotného stylu a je proto velice jednoduché jejich funkce kombinovat bez zbytečných zmatků. Jedná se tak o další způsob, jak ulehčit ponoření do R.\nJe nutné zmínit, že využívání Tidyverse není striktně nutné. Tidyverse vzniklo dlouho po vzniku samotného R a do dneška existuje mnoho uživatelů, pro které představuje základní R (nebo jiné balíčky pro analýzu dat) ideální pracovní prostředí. Nicméně, stejně jako u Rstudia, Tidyverse představuje skvělou rovnováhu mezi uživatelskou přívětivostí a flexibilitou práce."
  },
  {
    "objectID": "predstaveni.html#proč-ne-grafická-rozhraní",
    "href": "predstaveni.html#proč-ne-grafická-rozhraní",
    "title": "R, Rstudio, Tidyverse",
    "section": "Proč ne grafická rozhraní?",
    "text": "Proč ne grafická rozhraní?\nNakonec si dovolíme krátce vyjádřit k tématu, pravidelně objevuje vždy, když dojde na výuku analýzy dat.\nNa začátku jsme zmínili, že R je programovací jazyk a pro práci s ním je nutné znát základy programování. To striktně řečeno není úplně pravda. Protože je v R možné udělat téměř cokoliv, je možné v něm vytvořit i grafické rozhraní, a tím práci s ním přiblížit “klikacímu” softwaru jako je SPSS. Těchto rozhraní již dnes existuje celá řada, mezi nejpopulárnější se řadí například Jamovi a JASP. S využitím těchto rozhraní je možné analýzy “naklikávat” místo psaní programovacího kódu, čímž se výrazně snižuje vstupní bariéra. Grafická rozhraní ale podle našeho názoru mají tři velké slabiny, které dříve nebo později převáží nad jakýmikoliv potencionálními výhodami:\n\nGrafická rozhraní nikdy nepokryjí vše, co R nabízí a co potřebujeme: Přestože většina grafických rozhraní nabízí široké možnosti pro jednoduchou manipulaci s daty a základní statistické postupy, žádné z nich nepokrývá všechny potřeby průměrného výzkumníka, což platí zvláště pro pokročilejší analýzy. Jinak řečeno, ten kdo se rozhodne vážněji zabývat kvantitativní analýzou, se dříve nebo později alespoň lehkému programování nevyhne. A čas do té doby strávený v grafických rozhraních mu v tu chvíli nebude příliš užitečný.\nGrafické rozhraní jsou časově neefektivní: Nedokonalá nabídka není jediným problémem grafických rozhraní. I kdyby v nich byly obsaženy všechny nezbytné funkce, práce s grafickými rozhraními bude v dlouhodobém horizontu vždy pomalejší, než psaní kódů. Jedním z největších výhod, které počítače přinášejí, je možnost automatizace. Proč ručně vytvářet tucet kontingenčních tabulek nebo kontrolovat desítky proměnných, pokud to může počítač udělat za nás? Práce se skriptem nám umožní zadat počítači příkaz a nechat ho, ať ho sám provede na jakkoliv velkém počtu případů. Takovéto efektivity grafická rozhraní zkrátka nikdy nedosáhnou.\nKlikání svádí k nereprodukovatelnosti: Počítačový skript není jen způsob, jak počítači říkat, co má dělat. Jedná se zároveň o detailní záznam celé naší práce. Kdokoliv, ať už mi sami nebo lidé se zájmem o naši práci, se mohou v budoucnu podívat, jak jsme v analýze postupovali a případně se naší prací inspirovat nebo ji vylepšit. To je nejen skvělý nástroj pro ušetření času, ale i cesta ke zkvalitnění vědeckého výzkumu jako takového. Práce v grafickém rozhraní bohužel řadu lidí svádí k rychlému naklikávání, po kterém často nezůstane nic kromě řady pochybných výsledků, jejichž původem si není nikdo jistý."
  },
  {
    "objectID": "struktura.html",
    "href": "struktura.html",
    "title": "Struktura knihy",
    "section": "",
    "text": "Tato kniha je rozdělana do pěti sekcí.\nPrvní sekce názvem Trocha teorie vám pomůže nainstalovat všechen nezbytný software, předá vám tipy pro organizaci práce a seznámý vás se základním fungováním R jako programovacího jazyka.\nV druhé sekci Manipulace s dataframy se seznámíme s importem a exportem dat a se základní manipulací s daty, jako filtrování sloupců a řádků datasetů a se převodem dat mezi širokým a dlouhým formátem.\nTřetí v pořadi je sekce Manipulace s proměnnými si ukážeme jak transformovat a sumarizovat proměnné. Krátce se také dotkneme práce s strukturovaným a nestrukturovaným textem.\nČtvrtou sekcí je Vizualizace dat, jejímž obsahem je vytváření základních i pokročilých grafů, upravování jejich vzhledu a nakonec jejich export z R pro dalš použití.\nPoslední sekce nese název Pokročilé R a krátce si v ní představíme komplexnější, ale o to užitečnější funkce R, jmenovitě vytváření vlastních funkcí a for loop cykly."
  },
  {
    "objectID": "data.html#countries",
    "href": "data.html#countries",
    "title": "Data",
    "section": "Countries",
    "text": "Countries\nPrvním a hlavním je dataset countries. Dataset je možné stáhnout zde (klikněte pravým tlačítkem na odkaz a zvolte Uložit jako…). Popis proměnných naleznete v následující tabulce.\n\n\n\n\n\n\n\n\nJméno proměnné\nPopis\nZdroj\n\n\n\n\ncountry\nJméno země\n\n\n\ncode\nDvoumístný ISO kód země\n\n\n\ngdp\nHDP země v milionech euro (2018)\nEurostat\n\n\npopulation\nPopulace země k 1. lednu 2018\nEurostat\n\n\narea\nCelková rozloha země\nCIA factbook\n\n\neu_member\nJe země členem Evropské unie? (2019)\nEvropská unie\n\n\npostsoviet\nByla země součástí Východního bloku?\nWikipedie\n\n\nlife_exp\nNaděje na dožití při narození (2017)\nOSN\n\n\nuni_prc\nPodíl lidí s vysokoškolským vzděláním ve věku 15 až 64 let (2018)\nEurostat\n\n\npoverty_risk\nPodíl lidí ohrožených chudobou (2017)\nEurostat\n\n\nmaterial_dep\nPodíl lidí s materiální deprivací, 3 nebo méně položek (2017)\nEurostat\n\n\nhdi\nIndex lidského rozvoje (2018)\nOSN\n\n\nfoundation_date\nDatum vzniku/zformování země\nWikipedie\n\n\nmaj_belief\nNejvětší náboženská skupina v zemi (2018)\nPew Researcher Center"
  },
  {
    "objectID": "data.html#dogs",
    "href": "data.html#dogs",
    "title": "Data",
    "section": "Dogs",
    "text": "Dogs\nDataset věnovaný psím plemenům, původně z projektu TidyTuesday. Jedná se o dva datasety, první obsahuje vlastnosti psích plemen, druhý popularitu plemen v čase (pro stažení klikněte pravým tlačítkem na odkaz a zvolte Uložit jako…)."
  },
  {
    "objectID": "data.html#ukraine",
    "href": "data.html#ukraine",
    "title": "Data",
    "section": "Ukraine",
    "text": "Ukraine\nPoslední data se týkají postojů občanů České republiky k válce na Ukrajině z března 2022. Data pochází z dotazníkového šetření Centra pro výzkum veřejného mínění Akademie věd. První dataset obsahuje odpovědi respondentů, druhý popis jednotlivých proměnných."
  },
  {
    "objectID": "instalace.html#instalace-r",
    "href": "instalace.html#instalace-r",
    "title": "1  Instalace softwaru",
    "section": "1.1 Instalace R",
    "text": "1.1 Instalace R\nÚplně prvním krokem pro práci s R je, snad nepřekvapivě, instalace jazyka samotného.\n\n1.1.1 Windows\nR je možné stáhnout z oficiálních stránek projektu https://www.r-project.org. Čeští uživatelé budou pravděpodobně chtít stahovat z českého serveru, který je dostupný na adrese https://mirrors.nic.cz/R/index.html. Zde klikněte na Download R for Windows a poté na base. Po stažení je možné R nainstalovat jako jakýkoliv jiný program.\n\n\n\n\n\n\nVarování\n\n\n\nMožná víte, že existují dva typy procesorů, 32bitové a 64bitové. Setkat se dnes s 32bitovým procesorem je dnes poměrně vzácné, pokud ale takový počítač máte je nutné si dát pozor, jakou verzi R instalujete. Poslední verze R, která podporuje 32bitové procesory je 4.1., což není ta nejnovější. Pokud naopak máte 64bitový procesor, můžete si s klidem nainstalovat aktuální verzi R. Pokud si nejste jistí, můžete si procesor svého počítače zkontrolovat v nastavení. Obdobné omezení se týka i Rstudia, které podporuje 32bitové procesory pouze do verze 1.2.\n\n\nTi z vás, kteří preferují instalaci softwaru přes manager, mohou využít Chocolatey, Po instalaci manageru samotného stačí do terminálu zadat\nchoco install r\nUpozorňujeme ale, že z naší zkušenost se správcům Cholocatey balíčku ne vždy daří držet krok s aktuální oficiální verzí .\n\n\n1.1.2 MacOS\nR je možné stáhnout stejně jako u Windows verze z https://mirrors.nic.cz/R/, kde zvolte Download R for MacOS. Pokud máte Macbook s M1 procesorem (tedy Macbook z roku 2020 nebo mladší), zvolte verzi arm64. U starších verzí zvolte základní verzi R. Po stažení je možné nainstalovat jako jakýkoliv jiný software.\nPokud preferujete instalaci pomocí software manageru, je možné využít Homebrew. Pro instalaci Homebrew otevřete terminál a použijte příkaz\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\na řiďte se instrukcemi. Po úspěšné instalaci Homebrew je možné nainstalovat R pomocí příkazu:\nbrew install r \n\n\n1.1.3 Linux\nKonkrétní podoba instalace R pro Linuxu závisí na tom, jakou distribuci používáte. R oficiálně podporuje tři distribuce a to Debian, Ubuntu a Fedora/Redhead. Instrukce pro instalaci jsou dostupné na https://mirrors.nic.cz/R/. Velkou pozornost doporučujeme věnovat repozitářům pro instalaci balíčků, jelikož jejich napojení se liší distribuci od distribuce a jejich správnou přípravou si do budoucna ušetříte mnoho času!\nPokud používáte jinou než jednu z oficiálně podporovaných distribucí, konzultuje svůj package manager."
  },
  {
    "objectID": "instalace.html#instalace-rstudia",
    "href": "instalace.html#instalace-rstudia",
    "title": "1  Instalace softwaru",
    "section": "1.2 Instalace Rstudia",
    "text": "1.2 Instalace Rstudia\nPo instalaci R jste teoreticky připravení pro další práci! Rychle ale zjistíte, že obsluhovat R pouze z příkazové řádky není ani zdaleka ideální. Analytici a vývojáři proto využívají řadu programů, zvané Integrated Developer Environments (IDE), které psaní kódu usnadňují. Jedním z nejlepších (podle nás dokonce nejlepší!) IDE pro práci v R je Rstudio. Rstudio pro všechny operační systémy je dostupné ke stažení na https://www.rstudio.com/products/rstudio/download/#download. Instalace probíhá klasickým způsobem.\nTi z vás, kteří používají software manager, mohou využít Chocolatey pro Windows (choco install r.studio), Homebrew pro MacOS (brew install rstudio), případně konzultovat dokumentaci k vaší Linux distribuci.\nRstudio při prvním spuštění vypadá zhruba takto:"
  },
  {
    "objectID": "instalace.html#instalace-tidyverse",
    "href": "instalace.html#instalace-tidyverse",
    "title": "1  Instalace softwaru",
    "section": "1.3 Instalace Tidyverse",
    "text": "1.3 Instalace Tidyverse\nPosledním krokem je instalace sady R balíčků Tidyverse, které budeme využívat v rámci této knihy. Tyto balíčky lze nainstalovat uvnitř Rstudia pomocí příkazu install.packages(\"tidyverse\") zadaného do konzole na levé straně (nezapomeňte na uvozovky!):\n\nInstalace všech potřebných balíčků trvá zpravidla pár minut (s výjimkou některých uživatelů Linuxu, kteří musí balíčky kompilovat. Vy si počkáte zhruba tři čtvrtě hodiny). Úspěšná instalace bude zakončená větou package tidyverse successfully unpacked and MD5 sums checked."
  },
  {
    "objectID": "instalace.html#základní-nastavení-rstudia",
    "href": "instalace.html#základní-nastavení-rstudia",
    "title": "1  Instalace softwaru",
    "section": "1.4 Základní nastavení Rstudia",
    "text": "1.4 Základní nastavení Rstudia\nJako úplně poslední věc se vyplatí změnit dvě výchozí nastavení, kterými si dlouhodobě ušetříte práci i nervy. Rstudio ve výchozím nastavení při ukončení ukládá všechny nahraná data a další vámi vytvořené objekty a znovunahraje je pokaždé, když R znovu zapnete. To je ovšem v praxi spíše na škodu, protože to znamená, že zanedlouho budete mít vaše prostředí zaneřáděné daty z předchozích analýz a projektů. Tomu se dá jednoduše zabránit tím, že si v Rstudiu otevřete záložku Tools, a v ní volbu Global options. V tomto nastavení odškrtněte možnost Restore .Rdata into workspace at startup a zároveň nastavte možnost Save workspace to .Rdata on exit na never tak, jak je to na obrázku níže."
  },
  {
    "objectID": "rstudio.html#orientace-v-rstudiu",
    "href": "rstudio.html#orientace-v-rstudiu",
    "title": "2  První pohled na Rstudio",
    "section": "2.1 Orientace v Rstudiu",
    "text": "2.1 Orientace v Rstudiu\nPrvním krokem, který učiníte téměř vždy při zapnutí Rstudia, je otevření nového skriptu. To je možné udělat pomocí klávesové zkratky Ctrl + Shift + N na Windows a Linuxu, případně Cmd + Shift + N na MacOS. A nebo můžete kliknout na File -> New File -> R Script v pravém horním rohu. Vaše Rstudio bude vypadat zhruba takto:\n\nRstudio je rozděleno do čtyřech oblastí:\nSkript se nachází v levém horním rohu a je jedním z nejdůležitějších součástí Rstudia. Zde budete psát kód říkající R co má dělat, od importu dat až vytváření statistických modelů. Většinu času strávíte právě v tomto okně.\n\n\n\n\n\n\nKomentování kódu\n\n\n\nJednou z nejužitečnějších vlastností skriptu je možnost komentovat si vlastni kód. Komentář vytvoříte pomocí #. R bude vše za tímto znakem ignorovat, čímž se vám otevírá prostor pro vlastní poznámky. Například:\n\n# Dnes se seznámíme s R\n\n\n\nKonzoli najdeme v levém dolním rohu. V konzoli bude R zobrazovat výsledky vašeho kódu, upozornění a chybové hlášky, takže se ji vyplatí pozorně sledovat! I zde můžete zadávat instrukce pro R, ale pouze řádek po řádku, takže budeme preferovat psání kódu ve skriptu.\nV pravé vrchní části se nachází okno sloužící hned několika účelům. Tím nejdůležitějším pro začínající analytiky je Environment, ve kterém uvidíte importovaná data a další objekty, které během své práce vytvoříte.\nPoslední část Rstudia je v pravé spodní části a najdeme v ní hned několik užitečných věcí. Tou první je záložka Files, ve které uvidíme obsah vašeho současného pracovního adresáře (o tom později). Druhou důležitou záložkou je Plots, kde se budou zobrazovat vámi vytvořené grafy. Poslední záložkou je Help, obsahující dokumentaci k R a jeho funkcím. Do ní zavítáte pokaždé, pokud si nebudete jistí jak některá z funkcí funguje."
  },
  {
    "objectID": "rstudio.html#nastavení",
    "href": "rstudio.html#nastavení",
    "title": "2  První pohled na Rstudio",
    "section": "2.2 Nastavení",
    "text": "2.2 Nastavení\nPřestože Rstudio je možné bez větších problémů používat v jeho základním nastavení, v průběhu času si ho pravděpodobně budete chtít pro větší pohodlí. Většina nastavení Rstudia je dostupná v záložce Tools -> Global Options na vrchní liště. Pokud jste se řídili našemi instrukcemi pro instalaci (viz Kapitola 1 ), tak už jste do nastavení Rstudia na chvíli zavítali, abyste vypnuli automatické ukládání pracoviště. Pokud jste tak ještě neučinili, silně doporučujeme to udělat teď.\nMožnosti nastavení, které Rstudio nabízí, jsou široké a doporučujeme si je v klidu všechny projít. Pro začátek doporučujeme věnovat pozornost třem záložkám, a to General, Appearance a Pane Layout. V záložce General, kromě již zmíněného nastavení pro ukládání pracoviště, stojí za pozornost zejména Default working directory (when not in a project). Toto je adresář, do kterého bude R ukládat všechny výstupy, pokud neřeknete jinak. Pokud si rádi udržujete na svém počítači pořádek, můžete R přesměrovat do vlastní složky.\nV záložce Appearance je možné nastavit velikost a font písma a celkový vzhled Rstudia. Pokud je na vás výchozí písmo příliš malé nebo se vám nelibí výchozí barevné schéma, zde je možné to napravit.\n\n\n\n\n\n\nVíc schémat, víc!\n\n\n\nRstudio nabízí malý výběr barevných schémat (themes). Pokud vám není žádné z nich po chuti, je možné si vytvořit vlastní nebo si stáhnout schéma vytvořené jinými uživateli. K tomu je ideální stránka https://tmtheme-editor.herokuapp.com. Zde si můžete prohlédnout galerii schémat (gruvbox je naše oblíbené!) nebo si vytvořit vlastní. Jakmile najdete schéma, se kterým jste spokojení, stáhněte si ho a naimportujte ho v záložce Appearence.\n\n\nPoslední záložkou, do které mnoho uživatelů zavítá jako do jedné z prvních, je Pane Layout. Zde si můžete upravit rozložení Rstudia. Chcete mít konzoli napravo od skriptu? Nepotřebujete některou ze záložek? Zde si můžete nastavit vše k vaší spokojenosti.\nV menu nastavení samozřejmě najdete mnoho dalšího. Uživatelé Pythonu budou jistě potěšeni záložkou stejného jména. Programátoři mohou nastavit své version control nástroje v záložce Git/SVN. Pokud plánujete využivát Rstudio pro psaní reportů, záložky Rmarkdown a Spelling jsou pro vás. Nemusíte se ale stresovat, pokud pro většinu z těchto možností nevidíte v tuto chvíli využití. Postupem času se možná dostanete do situace, kdy se vám vyplatí s těmito možnostmi pohrát. Do té doby bude dobře sloužit výchozí nastavení."
  },
  {
    "objectID": "organizace.html#sec-rstudio-projects",
    "href": "organizace.html#sec-rstudio-projects",
    "title": "3  Jak si organizovat práci",
    "section": "3.1 Rstudio projekty",
    "text": "3.1 Rstudio projekty\nPrvní tip se týká organizace souborů, se kterými pracujeme. Ty mohou být cokoliv od datasetů, dotazníků a codebooků až po vytvořené grafy a reporty. Naše první rada je zde jednoduchá: Každý projekt, na kterém pracujete, by měl mít svou vlastní složku. To se může zdát triviální, znepokojivě velké množství lidí si ovšem osvojilo zvyk ukládat všechny své soubory v jedné obří složce. Ve výsledku to vede pouze ke zmatenému hledání, který z souborů pojmenovaný data-kopie3.csv obsahuje data, která hledáme.\nPokud používáte Rstudio, můžeme organizaci souborů usnadnit ještě o něco více. Každý projekt by měl mít svůj vlastní Rstudio projekt. Rstudio projekt je v podstatě jen složka, obsahující soubor s koncovkou .Rproj. To se může zdát triviální, tyto projekty jsou ale extrémně užitečné, protože umožňují Rstudiu automaticky nastavit pracovní adresář (s ním se setkáme při importu dat), ukládat historii vaší práce pro každý pracovní projekt zvlášť a mnoho dalšího. Jedná se tedy o skvělý nástroj, jak si udržet pořádek, zvláště pokud pracujete na několika projektech najednou.\nNový Rstudio projekt vytvoříte kliknutím na File -> New Project… v levém horním rohu. V otevřeném menu zvolte New Directory -> New Project a vyberte si název a adresu, kde má být projekt vytvořen. Pokud už máte složku, ze které byste chtěli vytvořit Rstudio projekt, stačí zvolit Existing Directory. Po vytvoření se nový Rstudio projekt automaticky otevře. Pokud byste Rstudio projekt zavřeli, můžete ho znovu otevřít v pravém horním rohu kliknutím na malou modrou ikonu R, za kterou následuje buď Project: (None), případně název současně otevřeného projektu. Na tomto místě můžete také přepínat mezi projekty nebo je zavřít."
  },
  {
    "objectID": "organizace.html#organizace-projektů",
    "href": "organizace.html#organizace-projektů",
    "title": "3  Jak si organizovat práci",
    "section": "3.2 Organizace projektů",
    "text": "3.2 Organizace projektů\nTeď, když je vaše práce organizovaná do (Rstudio) projektů, můžeme se zaměřit na to, jak organizovat jednotlivé soubory. Udržujte přehlednou a konzistentní strukturu napříč všemi projekty.\nVšechny vaše soubory by v rámci jednoho projektu měli být roztříděny do srozumitelně pojmenovaných podsložek. Konkrétní struktura projektu závisí na osobních preferencích a povaze práce, nám se obecně osvědčilo následující schéma:\nproject/\n|-data-raw/\n|-data-cleaned/\n|-scripts/\n|-documentation/\n|-outputs/\n|-project.Rproj\nSložka projektu by měla obsahovat alespoň následující podsložky a soubory. V podsložce data-raw jsou uchována data se kterými pracujeme, a to v takové podobě, v jaké se k nám dostala. Tato syrová data nikdy nepřepisujeme! Slouží jako poslední záchrana, pokud by bylo nutné provést všechny analýzy znovu od začátku. Naproti tomu, složka data-cleaned je pro již zpracovaná data. Nachází se zde vyčištěná data ze složky data-raw, připravená k další analýze. Data v té složce můžeme přepisovat, protože v případě potřeby je můžeme vždy znovuvytvořit pomocí našich skriptů. Skripty samotné bydlí …(dramatická pauza)… ve složce scripts. Zde asi není nutní mnoho vysvětlovat. Ve slože documentation je uchována dokumentace k projektu. Zpravidla se jedná o PDF verze dotazníků, popis sběru dat, codebooky a podobně. Poslední složkou je output, do které ukládáme všechny naše výstupy, ať už se jedná o dílčí grafy nebo celé reporty. V kořenovém adresáři se nachází pouze soubor .Rproj (který Rstudiu říká, že tato složka je Rstudio projekt).\nNa konci kurzu Úvodu do R by složka vašeho Rstudio projektu mohla vypadat zhruba nějak takto:\nuvod-do-r/\n|-data-raw/\n  |-countries.csv\n  |-cvvm-cerven-2019.csv\n|-data-cleaned/\n  |-countries-clean.csv\n|-scripts/\n  |-01-import-export.R\n  |-02-data-manipulation.R\n  |-03-data-visualization.R\n  |-04-final-homework.R\n|-documentation/\n  |-cvvm-codebook.pdf\n|-outputs/\n  |-vomacka-intro-r-homework.docx\n|-uvod-do-r.Rproj\nJakmile si najdete svou preferovanou strukturu svých souborů, dodržujte ji napříč všemi projekty. To vám umožní se rychle zorientovat i v projektech, na kterých jste řadu týdnů nebo dokonce měsíců nepracovali.\nSamozřejmě, ne všechny projekty mohou mít úplně identickou strukturu a občas je nutné strukturu složek přizpůsobit konkrétnímu projektu. I projekt, který obsahuje kód k této knize, je organizovaný výrazně jinak! Výše popsané schéma ale z naší zkušenosti představuje solidní základ pro projekty, na kterých sociální vědci zpravidla pracují."
  },
  {
    "objectID": "organizace.html#pojmenovávání-souborů",
    "href": "organizace.html#pojmenovávání-souborů",
    "title": "3  Jak si organizovat práci",
    "section": "3.3 Pojmenovávání souborů",
    "text": "3.3 Pojmenovávání souborů\nPořádek se vyplatí udržovat nejen při organizaci souborů, ale i při jejich pojmenovávání. Nadevše ostatní by vaše soubory měli mít srozumitelná, krátká jména. Datové soubory by měli být pojmenované tak, aby bylo ze jména jasné, jaká data obsahují. Například, pro data sesbírána Centrem pro výzkum veřejného mínění v červnu 2019 preferujeme názvy jako cvvm-cerven-2019.csv, spíše než V0619.csv. Pro oddělení více slov doporučujeme používat buď - nebo _, naopak se vyhýbejte mezerám. Přestože v dnešní době si většina programů dokáže s mezerami ve jménech souborů poradit, čas od času je možné narazit na situace, kde jsou mezery problematické. Skripty by měli být očíslované v pořadí odrážejícím postup analýzy. Názvy by zpravidla měli obsahovat pouze malá písmena.\n\n\n\n\n\n\n“Version control” aneb konec report-v1-finalni3.docx\n\n\n\nProblémem, který je nám všem jistě dobře známý, je jak udržovat pořádek v souborech, které jsou průběžné aktualizovány. Ať už se jedná o textové dokumenty, které prochází korekturami a zpětnou vazbou, nebo skripty které jsou pravidelně aktualizovány, většina lidí se dříve nebo později dostane do situace, kdy zírá do obrazovky a říká si “Počkat, která verze mého reportu je ta aktuální?” A nedejbože pokud bychom potřebovali zjistit, čím přesně se od sebe dvě různé verze stejného dokumentu liší.\nJednou možností, jak tomu předejít, je skálopevně dodržet některou pojmenovávací konvenci a poctivě číslovat každou novou verzi všech souborů. V dnešní době už ale existují i lepší řešení. Většina úložišť poskytuje službu zvanou version control, tedy automatické sledování provedených změn. Místo toho, abyste po každé změně vytvářeli novou kopii souboru, pracujete pouze s jednou kopií a necháte na počítači, aby zaznamenával celou historii úprav. U každé větší změny můžete do historie zanést krátkou poznámku, v čem se tato verze liší od té předchozí. Version control je dostupná pro většinu úložišť včetně Google Drive a OneDrive. Pokud píšete velké množství kódu, doporučujeme využít některé ze specializovaných úložišť jako je Github."
  },
  {
    "objectID": "organizace.html#sec-coding-styles",
    "href": "organizace.html#sec-coding-styles",
    "title": "3  Jak si organizovat práci",
    "section": "3.4 Kódovací styly",
    "text": "3.4 Kódovací styly\nKódovací styly (coding styles) představují seznam pravidel pro psaní dobře čitelného kódu. Silně doporučujeme dodržovat jeden kódovací styl. Dodržovaní vámi vybraného stylu pomůže váš kód udržovat dobře čitelný a přehledný, a to nejen pro vaše budoucí já, ale i pro vaše spolupracovníky.\nJednou z typických věcí, kterou kódovací styly upravují, je pojmenovávání proměnných. Způsobů pojmenovávání proměnných existuje více, mezi ty nejpopulárnější patří následující tři:\nsnake_caseje styl, který používá malá písmena a slova odděluje podtržítkem. Například proměnná obsahující měsíční příjem respondenta by ve snake_case stylu vypadalo jako monthly_income.\ncamelCase styl pro oddělení slov využívá velkých písmen, zbylá písmena jsou malá. Průměrný měsíční příjem by v tomto stylu byl monthlyIncome.\nkebab-case je styl podobý snake_case, místo podtržítek ale využívá pomlček. Naše proměnná příjmu by v vypadalo jako monthly-income.\nKód v této knize se řídí Tidyverse coding style guide. To rozhodně není jediný používány styl (např. Google má svůj vlastní) a rozhodně se nedá říct, že by byl lepší než všechny ostatní. V budoucnu si možná vybudujete svůj vlastní styl, ušitý na míru vašim potřebám. Ze začátku ovšem doporučujeme vybrat si jeden z populárních stylů a dát si záležet na jeho dodržování. Vaše budoucí já i vaši kolegové vám za to poděkují."
  },
  {
    "objectID": "objekty.html#atomové-vektory",
    "href": "objekty.html#atomové-vektory",
    "title": "4  Typy objektů",
    "section": "4.1 Atomové vektory",
    "text": "4.1 Atomové vektory\nNejzákladnějšími objekty je takzvané atomické vektory (atomic vectors). Atomické vektory jsou základním stavebním kamenem R a všechny ostatní objekty, se kterými se setkáme, z nich vychází. Každý vektor je složen z určitého počtu elementů, tedy dílčích částí. Atomový vektor s jedním elementem představuje základní jednotku informace. Příkladem takového vektoru je:\n\n\"Fred\"\n\n[1] \"Fred\"\n\n\nVýše zmíněný je takzvaný character vektor, obsahující jeden element, Fred. Vektory ale mohou obsahovat i více elementů:\n\nc(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\")\n\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n\nNa rozdíl od předchozího příkladu, tento vektor obsahuje pět elementů. Všimněte si, že elementy jsou spojeny do jednoho vektoru pomocí funkce c() (zkratka pro combine). R zná čtyři typy atomových vektorů:\n\nTypy atomových vektorů\n\n\n\n\n\n\n\nTyp\nPopis\nPříklady\n\n\n\n\ncharacter\nPísmena a další znaky. Poznáte je podle toho, že elementy jsou “obaleny” úvozkovami (\" nebo ').\n\"Fred\", \"?\", \"1\"\n\n\ninteger\nCelá čísla. Spolu s typem double tvoří skupinu numerických (numeric) vektorů.\n-1, 316, 17\n\n\ndouble\nDesetinná čísla. Zkratka pro double precision floating point format. Spolu s typem integer tvoří skupinu numerických (numeric) vektorů.\n1.32, 0.1, -9.0\n\n\nlogical\nBinární vektor, který může nabývat pouze dvou hodnota: pravda (TRUE) a nepravda (FALSE).\nTRUE, FALSE\n\n\n\n(Technicky existují ještě dva další typy atomových vektorů, raw a complex, s těmi se ovšem běžný uživatel nikdy nesetká, takže je přeskočíme.)\n\n\n\n\n\n\n1 není “1”\n\n\n\nPři práci s R je třeba si dát pozor na to, že ne vše, co vypadá jako číslo, nutně číslo je. R vám s radostí spočítá průměr vektoru c(1,2,3), pokud byste se pokusili spočítat průměr vektoru c(\"1\", \"2\", \"3\"), narazíte na problém a chybovou hlášku. Proč? Protože zatímco první vektor je typu numeric (konkrétně integer), druhý vektor je typu character. R tedy druhý vektor vidí v podstatě jako písmena a pro písmena se průměr spočítat přeci nedá!\n\n\nPro atomové vektory platí, že jejich elementy musí být stejného typu. Není tedy možné vytvořit atomový vektor, který by byl kombinací znaků a čísel (c(18, \"Fred\"). Pokud se to pokusíte, R vás buď zastaví nebo převede všechny elementy do stejného typu (c(\"18\", \"Fred\")). Na toto automatické převádění elementů typů si dávejte pozor, jedná se o častý zdroj chyb a problémů.\nKromě běžných hodnot, kterých mohou elementy nabývat, existují tři speciální hodnoty, se kterými se budeme setkávat. Těmi jsou NA a NULL aNaN. NA představuje chybějící hodnotu ve statistickém smyslu slova. Setkáme se s ní pokud respondenti odmítnou odpovědět na některou z otázek v dotazníkovém šetření nebo pokud R nemá dostatek informací pro výpočet nějaké veličiny. Jedná se tedy o hodnotu existující, ale nám neznámou. Naproti tomu NULL reprezentuje absenci platné hodnoty. Setkáme se s ní v situaci, kdy žádné pozorování v datasetu neodpovídá námi specifikovaným filtrům. Hodnota NaN je zkratkou pro “Not a Number”. Pokud se s ní setkáte, znamená to zpravidla, že jste se dopočítali někam, kam jste nechtěli."
  },
  {
    "objectID": "objekty.html#sec-factors",
    "href": "objekty.html#sec-factors",
    "title": "4  Typy objektů",
    "section": "4.2 Faktory",
    "text": "4.2 Faktory\nKomplikovanějším typem vektoru jsou takzvané faktory. Jedná se v podstatě integer vektory, jejichž hodnotám bylo přiřazeno slovní označení (label):\n\n\n[1] Agree    Neutral  Disagree\nLevels: Agree Disagree Neutral\n\n\nPřestože se faktory na první pohled tváří jako běžné character vektory, každé kategorii byla přiřazena číselná hodnota. V našem případě \"Agree\" = 1, \"Disagree = 2, \"Neutral = 3\" (všimněte si, že číselné hodnoty byly přiřazeny podle abecedního pořadí slovních označení). Toho mnoho R funkcí využívá při statistických výpočtech, v rámci kterých je třeba zakódovat kategorické proměnné do číselných hodnot. S faktory se proto v datové analýze setkáme velmi často, ať už se bude jednat o odpovědi na likertovské položky v dotazníkových šetřeních, název bydliště nebo třeba název prodaného produktu.\nDalší důležitou vlastností faktoru je, že mohou nabývat pouze hodnot, které byly definovány při jejich vytvoření:\n\nfactor(x = c(\"Agree\", \"Neutral\", \"Disagree\", \"Don't know\"),\n       levels = c(\"Agree\", \"Neutral\", \"Disagree\"))\n\n[1] Agree    Neutral  Disagree <NA>    \nLevels: Agree Neutral Disagree\n\n\nPřestože se v “datech” se vyskytují čtyři různé hodnoty, hodnota \"Don't know\" byla po vytvoření faktoru převedena na NA. Důvodem je, že jsme při vytváření našeho faktoru uvedli pouze tři platné hodnoty: \"Agree\", \"Neutral\", \"Disagree\" a žádná další nebude naším faktorem akceptována. Tato vlastnost se hodí zejména v situacích, kdy víme, jakých hodnot může proměnná nabývat, například u likertovských položek, a všechny ostatní naměřené hodnoty jsou nutně chybné.\nNakonec ještě zmiňme, že kromě klasických faktorů existují také takzvané ordered factors. Historicky se jednalo o faktory, které nemají pevně dané pouze to, jakých hodnot mohou elementy nabývat, ale i v jakém pořadím mají být seřazeny. Většina současných funkcí mezi klasickými a ordered faktory nerozlišuje, takže se jimi zpravidla nemusíte trápit.\nKlasický faktor lze vytvořit funkcí factor(), ordered faktor poté pomocí funkce ordered()."
  },
  {
    "objectID": "objekty.html#matice-a-tabulky",
    "href": "objekty.html#matice-a-tabulky",
    "title": "4  Typy objektů",
    "section": "4.3 Matice a tabulky",
    "text": "4.3 Matice a tabulky\nDo této chvíle jsme viděli pouze jednorozměrné vektory, jako je například řada jmen v character vektoru. V datové analýze se ale budeme běžně setkávat i s vícerozměrnými objekty, z nichž tím nejzákladnějším je matice (matrix). Jedná se o starou známou matici, kterou si můžete pamatovat z hodin matematiky:\n\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n\n\nV příkladu výše vidíme dvourozměrnou matici s devíti elementy. Matice mohou mít i více dimenzí a v takovém případě jim říkáme arrays.\nMatice jsou samozřejmě extrémně důležité pro jakoukoliv manipulaci s daty. Pokud si již ovšem z hodin lineární algebry mnoho nepamatujete, nemusíte panikařit. Mnoho funkcí sice matice interně využívá, jejich uživatelé to ovšem často ani nepostřehnout. Matematické operace jsou v R značně abstrahované a většina běžných datových analytiků proto s maticemi interaguje minimálně. Pokud byste je někdy potřebovali vytvořit, poslouží vám k tomu funkce matrix() a array().\nTypem objektu, se kterým se setkáte o něco častěji, je tabulka (table). Tabulky jsou také maticemi, jejichž dimenzím byla přiřazena slovní označení. Nejčastěji se s tabulkami setkáme při agregací vektorů. Příkladem tabulky je například\n\n\n\nDislike    Like \n      7      13 \n\n\nTato tabulka je výsledkem funkce table(), aplikované na atomový character vektor obsahující sedmkrát hodnotu Dislike a třináctkrát hodnotu Like. Studenti sociálních věd také jistě budou znát kontingenční tabulky, tedy frekvenční tabulky pro dvě nebo více proměnných:\n\n\n         Preference\nTransport Dislike Like\n     Bike       4    6\n     Bus        5    5\n     Car        4    6\n\n\nJak matice, tak tabulky, mohou nepřekvapivě obsahovat pouze numerické elementy."
  },
  {
    "objectID": "objekty.html#listy",
    "href": "objekty.html#listy",
    "title": "4  Typy objektů",
    "section": "4.4 Listy",
    "text": "4.4 Listy\nVšechny předchozí typy objektů mohli uchovávat pouze elementy stejného typu. Realita je ovšem komplikovanější a je na nás, abychom se jí přizpůsobili.\nZákladním typem objektu pro uchovávání elementů různého typu je list:\n\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"Fred\"\n\n[[3]]\n[1] TRUE\n\n\nListy mohou uchovávat objekty různých typů, v podstatě bez jakýchkoliv omezení. List může dokonce obsahovat jiný list! Poradí si dokonce i s objekty různé délky:\n\n\n[[1]]\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n[[2]]\n[1]  42.0   1.3 666.0\n\n[[3]]\n[1]  TRUE FALSE\n\n[[4]]\n[[4]][[1]]\n[1] \"Car\"\n\n[[4]][[2]]\n[1] \"Bus\"\n\n[[4]][[3]]\n[1] \"Bike\"\n\n\nDíky své flexibilitě se listy využívají primárně pokud chceme uchovávat velmi různorodá data na jednom místě. Většina výstupů statistických analýz bude právě ve formě listu. List je možné vytvořit funkcí list()."
  },
  {
    "objectID": "objekty.html#dataframy",
    "href": "objekty.html#dataframy",
    "title": "4  Typy objektů",
    "section": "4.5 Dataframy",
    "text": "4.5 Dataframy\nTo nejlepší jsme si nechali nakonec. Zdaleka nejužitečnějším typem objektu pro datového analytika je dataframe:\n\n\n      V1 V2    V3\n1   Fred 16 FALSE\n2 Daphne 16 FALSE\n3  Velma 15 FALSE\n4 Shaggy 17 FALSE\n5 Scooby  3  TRUE\n\n\nDataframy slouží stejnému účelu jako spreadsheety v jiných softwarech. Je v nich uchovávaná drtivá většina všech dat a pracuje s nimi většina funkcí, se kterými se v této knize setkáme. U běžného dataframu platí, že každý sloupec představuje jednu proměnnou a každý řádek jedno pozorování (např. respondenta).\nZvláštní vlastností dataframů je, že všechny jeho elementy musí být stejně dlouhé. Jinak řečeno, pro každou proměnnou musíme mít stejný počet pozorování. Co když tomu tak není? V takovém případě vstupuje do hry hodnota NA, zmíněná dříve, která kóduje chybějící hodnoty. Například v následujícím dataframu máme ve druhém sloupci jen čtyři hodnoty, plus jednu NA:\n\n\n      V1 V2    V3\n1   Fred 16 FALSE\n2 Daphne 16 FALSE\n3  Velma 15 FALSE\n4 Shaggy NA FALSE\n5 Scooby  3  TRUE\n\n\nJak jsme již zmínili, naprostá většina naší práce bude probíhat v dataframech. Konkrétně budeme využívat speciální typ dataframu, zvaný tibble. Tibble je druh dataframu pocházející z Tidyverse, a většinou se chová identicky jako jeho základní varianta. Hlavním rozdílem je o něco hezčí vzhled.\nKlasický dataframe je možný vytvořit funkcí data.frame(), tibble poté pomocí funkce tibble()."
  },
  {
    "objectID": "jmena.html#přiřazování-jmen",
    "href": "jmena.html#přiřazování-jmen",
    "title": "5  Jména objektů",
    "section": "5.1 Přiřazování jmen",
    "text": "5.1 Přiřazování jmen\nV předchozí kapitole jsme si představili nejdůležitější typy objektů. Řekli jsme si také, jak můžeme objekty vytvářet. Character vektor bychom například vytvořili takto:\n\nc(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\")\n\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n\nS takto vytvořeným vektorem se nám ale nebude dobře pracovat. To proto, že R ho vytvoří, vytiskne do konzole a promptně zapomene. Pokud si chceme data odložit na později, je nutné objektu, ve kterém jsou uložena, přiřadit jméno. Přiřazování jmen je velmi jednoduché:\n\nname <- c(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\")\n\nV tomto případě jsme našemu vektoru přiřadili jméno name. Obsah vektoru nebyl vytisknut v konzoli. Místo toho ho R uložilo do paměti a pokud používáte Rstudio, můžete ho vidět v pravém horním rohu v záložce Environment. K přiřazování jmen se využívá operátor <-, který nejsnadněji vytvoříte pomocí klávesové Alt + - (resp. option + - na MacOS). Alternativně můžete použít =, výsledek bude stejný:\n\nname = c(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\")\n\nJakmile má objekt přiřazené jméno, můžeme na něj v budoucnu odkazovat. Pokud bychom chtěli zjistit kolik elementů náš vektor má, můžeme použít funkci length():\n\nlength(name)\n\n[1] 5\n\n\nJak je vidět, objekt name obsahuje pět elementů.\n\n\n\n\n\n\n“<-” nebo “=” ?\n\n\n\nNěkteří čtenáři si teď možná nejsou jistí, který z operátorů by měli používat pro pojmenovávání objektů, <- nebo =? Krátce řečeno, na vaší volbě nezáleží.\nPro delší odpověď je třeba znát trochu historie. R původně vzniklo na základě jazyka jménem S, který pro pojmenovávání objektů používal právě <-. Tento operátor převzalo i R, primárně pro zpětnou kompatibilitu. Od doby, kdy lidé ještě používali S, již dnes uběhlo skoro 20 let a zpětná kompatibilita s tímto jazykem není moc důležitá. Naopak přibylo uživatelů, kteří kromě R používají i jazyky jako Python a Javascript, využívající = operátor. Tito uživatelé přirozeně tíhnou k využívání = ve všech situacích.\nTechnicky vzato existuje velmi malé množství případů, kdy na rozdílu mezi <- a = záleží. Operátor <- má výší prioritu než =, což znamená, že pokud se R dostane do situace, kdy neví, který z nich vyhodnotit dřív, vybere si <-. V praxi k takovým situacím ale dochází naprosto minimálně. Zájemci o více detailů viz https://stackoverflow.com/a/51564252.\n\n\nJména můžeme stejným přiřazovat i elementům uvnitř složitějších objektů než jsou vektory, jako jsou listy a dataframy. Pokud bychom chtěli vytvořit dataframe a pojmenovat jednotlivé sloupce (proměnné), udělali bychom to následovně:\n\ngang <- data.frame(name   = c(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\"),\n                   age    = c(16, 16, 15, 17, 3),\n                   is_dog = c(FALSE, FALSE, FALSE, FALSE, TRUE))\n\nNáš nový dataframe můžeme zobrazit v konzoli pomocí funkce print():\n\nprint(gang)\n\n    name age is_dog\n1   Fred  16  FALSE\n2 Daphne  16  FALSE\n3  Velma  15  FALSE\n4 Shaggy  17  FALSE\n5 Scooby   3   TRUE\n\n\nNejenže můžeme pracovat s naším dataframem pomocí jeho jména (name), ale každý sloupec dataframu má jméno, které jsme muß přiřadili. O tom, jak pracovat s jednotlivými sloupci, si povíme v příští kapitole.\n\n\n\n\n\n\nJména elementů\n\n\n\nMéně používaná, ale občas užitečná, je možnost pojmenovávat jednotlivé elementy vektoru. Například:\n\nc(Fred = 16, Daphne = 16, Velma = 15, Shaggy = 17, Scooby = 3)\n\n  Fred Daphne  Velma Shaggy Scooby \n    16     16     15     17      3 \n\n\nTo se hodí zejména v například případech, kdy chceme mít informaci o to, co jednotlivé hodnoty znamenají, ale nechceme pro ně vytvářet novou proměnnou v dataframu."
  },
  {
    "objectID": "jmena.html#pravidla-pojmenovávání",
    "href": "jmena.html#pravidla-pojmenovávání",
    "title": "5  Jména objektů",
    "section": "5.2 Pravidla pojmenovávání",
    "text": "5.2 Pravidla pojmenovávání\nPřestože R nabízí značnou volnost v tom, jak své objekty pojmenujete, je nutné dodržovat alespoň některá pravidla. Jména musí začínat buď písmenem nebo tečkou. Pokud začínají tečkou, druhý znak nesmí být číslice (například .2scale tedy není použitelné jméno). Jména také mohou obsahovat pouze písmena, číslice, tečky nebo podtržítka (_). Žádné $, ~ a podobně.\nNásledující slova také nemůžou být jmény objektů: if, else, repeat, while, function, for, in, next, break, TRUE, FALSE, NULL, Inf, NaN, NA, NA_integer_, NA_real_, NA_complex_, NA_character_ a …. Těmto výrazům se říká rezervovaná slova a jsou využívaná pro vnitřní fungování R. Už jsme se například setkali s výrazem NA, který je rezervován pro vyjádření chybějících hodnot.\nKromě těchto pravidel, které musíte dodržovat ať se vám to líbí nebo ne, také silně doporučujeme, aby jména vašich objektů byla krátká, ale srozumitelná. Věk respondentů dotazníkového šetření by měl být ideálně uložen v proměnné age, spíše než I2 nebo age_of_respondents. Řiďte se také jednou z jmenovacích konvencí popsaných v kapitole Jak si organizovat práci. My osobně preferujeme snake_case, tedy všechna písmena malá a slova oddělená podtržítkem."
  },
  {
    "objectID": "funkce.html#používání-funkcí",
    "href": "funkce.html#používání-funkcí",
    "title": "6  Funkce",
    "section": "6.1 Používání funkcí",
    "text": "6.1 Používání funkcí\nPoužívat funkce je jednoduché. Každá funkce obsahuje argumenty, pomocí kterých funkci upřesňujete, co přesně má vykonat. Tyto argumenty si píší právě do závorek za jménem funkce. Funkce, kterou jsme viděli opakovaně, je například naše staré dobré c():\n\nname <- c(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\")\n\nV tomto případě jsme použili funkci c() pro vytvoření nového vektoru. Této funkci jsme zadali pět argumentů, definující z jakých elementů se má nový vektor skládat. Obdobně bychom na náš nový objekt name mohli použít funkci print():\n\nprint(name)\n\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n\nV tomto případě jsme funkci print() specifikovali pouze jeden argument, a to který objekt má vytisknout do konzole.\n\n\n\n\n\n\nUkládejte si své výsledky!\n\n\n\nČastým zdrojem zmatení u nových uživatelů bývá, že R zdánlivě dělá co mu říkají, ale výsledky nikdy neukládá! Toto nedorozumění je nejsnažnější vysvětlit na praktickém příkladu.\nCo kdybychom chtěli zaokrouhlit čísla v následujícím vektor?\n\nage <- c(16.45, 16.52, 15.9, 17.1, 3.234)\n\nZaokrouhlení čísel je jednoduchá záležitost, pro kterou můžeme využít funkci round():\n\nround(age)\n\n[1] 16 17 16 17  3\n\n\nA je zaokrouhleno. Nebo ne? Pokud se podíváme na vektor age, zjistíme že pořád obsahuje původní čísla:\n\nage\n\n[1] 16.450 16.520 15.900 17.100  3.234\n\n\nProč si R odmítá zapamatovat, že jsme čísla zaokrouhlili? Protože jsme mu neřekli, že má výsledek funkce round() uložit do paměti. Vektor se zaokrouhlenými čísly je objekt jako každý jiný a pokud ho chceme využívat v budoucnu, musíme mu přiřadit jméno. Pokud nám nevadí přijít o původní nezaokrouhlená jména, můžeme klidně použít jméno původního vektoru:\n\nage <- round(age)\nage\n\n[1] 16 17 16 17  3"
  },
  {
    "objectID": "funkce.html#sec-fn-arguments",
    "href": "funkce.html#sec-fn-arguments",
    "title": "6  Funkce",
    "section": "6.2 Argumenty funkcí",
    "text": "6.2 Argumenty funkcí\nJak jsme zmínili, každá funkce má argumenty, které ovlivňují její fungování. V předchozích příkladech sloužili argumenty primárně pro určení toho, se kterými daty má funkce pracovat. Většina argumentů ale upravuje primárně to, co má funkce s daty dělat. Pro ukázku si vytvořme nový vektor:\n\nage <- c(16, 16, 17, 15, NA)\n\nJedná se o numerický vektor, jehož poslední hodnota je neznámá (NA). Co kdybychom chtěli spočítat průměr těchto hodnot? K tomu poslouží funkce mean(), pokud bychom ji ale aplikovali na náš vektor, narazili bychom na problém:\n\nmean(age)\n\n[1] NA\n\n\nR nám říká, že průměr těchto čísel je NA, tedy neznámý. Proč? Narážíme tu na jistou pedantnost typickou pro R. R nám svým způsobem říká “Alespoň jedno z čísel v tomto vektoru je neznámé a může teoreticky nabývat jakékoliv hodnoty. Proto i výsledný průměr může nabývat jakékoliv hodnoty, a je tedy sám neznámý”. V tom má R jistě pravdu. Co kdybychom se ale spokojili s tím, že budeme neznámé hodnoty ignorovat a spočítat průměr jen pro známá čísla? Přesně k tomu má funkce mean() argument na.rm (remove NAs). Tento argument může nabývat dvou hodnot TRUE a FALSE. Ve výchozím nastavení je tento argument nastaven na FALSE, což mi ale můžeme jednoduše změnit:\n\nmean(age, na.rm = TRUE)\n\n[1] 16\n\n\nA je to! Pomocí argumentu na.rm jsme změnili fungování funkce mean() tak, aby ignorovalo neznámé hodnoty."
  },
  {
    "objectID": "funkce.html#sec-nested-objects",
    "href": "funkce.html#sec-nested-objects",
    "title": "6  Funkce",
    "section": "6.3 Funkce a vnořené objekty",
    "text": "6.3 Funkce a vnořené objekty\nV předchozí kapitole jsme si řekli, že většina dat je uchovávaných v dataframech. Jeden takový dataframe můžeme vytvořit pomocí:\n\ngang <- data.frame(name   = c(\"Fred\", \"Daphne\", \"Velma\", \"Shaggy\", \"Scooby\"),\n                   age    = c(16, 16, 15, 17, 3),\n                   is_dog = c(FALSE, FALSE, FALSE, FALSE, TRUE))\n\nCo kdybychom chtěli spočítat počet členů členů Scoobyho gangu? Jako první se nabízí možnost:\n\nlength(name) # Error: object 'name' not found\n\nTo ovšem nebude fungovat, protože R nemůže najít žádný objekt jménem name. Tento objekt je totiž vnořený (nested) uvnitř jiného objektu, gang a R nebude prohledávat všechny existující objekty pokaždé, když mu řekneme, aby aplikovalo některou funkci. Je tedy na nás, abychom R navedli, kde má proměnnou name hledat.\nToho lze docílit několik způsoby. Tím prvním je pomocí operátoru $. Tímto operátorem můžeme navigovat vnořenými objekty, například jím můžeme vybrat proměnnou name v dataframu gang:\n\nlength(gang$name)\n\n[1] 5\n\n\nR teď ví, že objekt name by mělo hledat unvitř objektu gang.\nSpecifikování vnořených objektu pomocí $ je asi nejpoužívanější způsob pokud pracujeme s dataframy, není ale jediný. Alternativní způsob představuje indexovaní pomocí hranatých závorek []. Ty lze aplikovat několika způsoby. Prvním z nich je skrze jméno vnořeného objektu:\n\ngang[\"name\"]\n\n    name\n1   Fred\n2 Daphne\n3  Velma\n4 Shaggy\n5 Scooby\n\n\nAlternativně můžeme využít pořadí řádků a sloupců v objektu. name je první proměnnou v dataframu gang a můžeme ji tedy vybrat následovně:\n\ngang[, 1]\n\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n\nVšimněte si, že závorky v tomto případě obsahují čárku ([, 1]). To proto, že pomocí hranatých závorek můžeme vybírat jak sloupce, tak řádky. Pořadí řádku se z konvence píše na první pozici, sloupce na druhé. Kdybychom se chtěli dozvědět více o Fredovi, mohli bychom použít:\n\ngang[1, ]\n\n  name age is_dog\n1 Fred  16  FALSE\n\n\n\n\n\n\n\n\nVylučovací metoda\n\n\n\nIndexování je možné využít i pro výběr všech sloupců/řádků kromě zmíněních. Pro vybrání všech sloupců kromě třetího použijeme gang[, -3].\n\n\nOboje možnosti je samozřejmě možné kombinovat. Hodnotu prvního řádku a prvního sloupce bychom získali následovně:\n\ngang[1,1]\n\n[1] \"Fred\"\n\n\nPokud tedy pracujeme s vnořenými objekty, a to budeme téměř neustále, nesmíme R nikdy zapomenout říct, kde má hledat.\n\n\n\n\n\n\n[[]] je více než []\n\n\n\nČas od času se můžete setkat s kódem využívajícím dvojité závorky ([[]]), místo jednoduchých ([]). Každá z těchto variant má své využití.\nVšimněme si, jaký typ objektu vrátí následující kód:\n\ngang[\"name\"]\n\n    name\n1   Fred\n2 Daphne\n3  Velma\n4 Shaggy\n5 Scooby\n\n\nJedná se o dataframe, stejně jako byl původní objekt, pouze byly odstraněny všechny sloupce kromě toho se jménem name. Co naproti tomu dělá následující kód?\n\ngang[[\"name\"]]\n\n[1] \"Fred\"   \"Daphne\" \"Velma\"  \"Shaggy\" \"Scooby\"\n\n\nTento kód vrátil stejné hodnoty, ale v jiném formátu. Už se nejedná o (filtrovaný) dataframe, ale o atomický vektor. Rozdíl mezi těmito dvěma způsoby vybírání vnořených objektů je důležitý, protože argumenty funkcí často očekávají data v určitém formátu."
  },
  {
    "objectID": "funkce.html#sec-pipes",
    "href": "funkce.html#sec-pipes",
    "title": "6  Funkce",
    "section": "6.4 Řetězení funkcí",
    "text": "6.4 Řetězení funkcí\nVšechny příklady, které jsme zatím viděli, aplikovali vždy pouze jednu funkci. Asi ovšem tušíte, že v reálné analýze budeme muset na naše data aplikovat mnohem více funkcí, než se dostaneme ke kýženým výsledkům. To s sebou přináší praktický problém. Jak na sebe efektivně řetězit větší počet funkcí tak, aby byl náš kód stále čitelný? V principu existují tři varianty.\nPrvní možnost je aplikovat funkci jednu po druhé a ukládat mezivýsledky do nových objektů:\n\nme_awake   <- wake_up(me)\nme_clean   <- wash(me_awake)\nme_fed     <- eat_breakfest(me_clean)\nme_working <- go_to_work(me_fed)\n\nTento postup je analogický tomu, co jsme dělali dosud. Aplikujeme funkci a její výsledek uložíme do nového objektu. Jedná se o vcelku přehledný postup, nevýhodou ovšem je, že vytváříme velké množství objektu, které zabírají místo a znepřehledňují naše prostředí.\nAlternativně je možné na sebe funkce “nabalovat”:\n\nme_working <- go_to_work(eat_breakfest(wash(wake_up(me))))\n\nTímto se vyhneme vytváření nových objektů, výsledný kód ovšem není příliš čitelný. Hlavním problém je, že pokud chceme vědět, co tento kód dělá, je nutné ho číst od středu. Jako první je aplikovaná funkce v “jádru”, tedy wake_up(), a poté všechny ostatní směrem k okraji. Funkce go_to_work() je aplikovaná jako poslední a to i přesto, že je na řádku jako první.\nPoslední, námi preferovanou, metodu je využívání takzvaných pipes. Používat budeme pipes z balíčku magrittr, který je součástí Tidyverse. Ty vypadají takto: %>% a aplikuje se následovně:\n\nme_working <- me %>% \n  wake_up() %>% \n  wash() %>% \n  eat_breakfest() %>% \n  go_to_work()\n\nPipes (%>%) vezmou objekt nalevo od nich a vloží ho do funkce napravo. První pipe tedy vezme objekt me a vloží ho do funkce wake_up(). Druhá pipe vezme výsledek funkce wake_up() a vloží ho do funkce wash(). Takto celý řetězec pokračuje dále až po funkci go_to_work(). Výsledek celého řetězce je uložen do objektu me_working tak, jak jsme zvyklý. Protože psát jednotlivé pipes ručně by bylo otravné, existuje pro ně v Rstudiu klávesová zkrátka Shift + Ctrl + M (respektive Shift + Command + M na MacOS).\nPipes jsou preferovaný způsob řetězení funkcí v Tidyverse a budou využívány ve zbytku této knihy. Jejich hlavní výhodou je, že výsledný kód je dobře čitelný, protože je možné ho číst zleva doprava, tak jak jsme zvyklí u normálního textu. Na druhou stranu, někteří lidé argumentují že takto psaný kód zabírá příliš mnoho místa.\n\n\n\n\n\n\nTidyverse vs základní pipes\n\n\n\nPipes byly v R dlouhou dobu čistě Tidyverse záležitostí. Od verze 4.1. jsou ale podporovány i základní instalací R a je tedy možné využívat tento způsob řetězení funkcí bez nutnosti instalovat další balíčky. Pipes v základním R vypadají a chovají se trochu odlišně od svých Tidyverse příbuzných. Základní verze pipes vypadá tako: |>. Příklad s řetězením funkcí by tedy vypadal následovně:\n\nme_working <- me |> \n  wake_up() |> \n  wash() |>\n  eat_breakfest() |> \n  go_to_work()\n\nKromě odlišného vzhledu se také obě verze chovají trochu jinak. Hlavním rozdílem je, že používají jiný “placeholder” pro specifikaci argumentů. Obě verze ve výchozím nastavení vloží objekt na jejich levé straně do prvního argumentu funkce napravo. Pokud bychom chtěli vložit objekt do jiného než prvního argumentu, je nutné využít právě placeholder. Tidyverse pipe používá jako placeholder tečku. Například, pokud bychom chtěli vložit objekt iris do argumentu data, který je na druhém místě funkce lm():\n\niris %>% lm(Sepal.Width ~ Species, data = .)\n\nNaproti tomu základní pipe využívá jako placeholder podtržítko:\n\niris |> lm(Sepal.Width ~ Species, data = _)\n\nKromě placeholderů se obě verze pipes liší i interním fungováním. Ve zkratce řečeno, tidyverse pipe je flexibilnější a umí více věcí, základní pipe je zhruba dvakrát až třikrát rychlejší.\nPokud byste si chtěli základní verzi pipe vyzkoušet, můžete upravit klávesovou zkratku Shift + Ctrl + M tak, že půjdete do Tools -> Global Options -> Code -> Use native pipe operator."
  },
  {
    "objectID": "funkce.html#dokumentace-funkcí",
    "href": "funkce.html#dokumentace-funkcí",
    "title": "6  Funkce",
    "section": "6.5 Dokumentace funkcí",
    "text": "6.5 Dokumentace funkcí\nPo všem tom povídání si teď možná říkate, jak si má člověk zapamatovat, co která funkce dělá, nemluvě o tom, jaké má argumenty. Naštěstí pro nás si toho moc nazpaměť pamatovat nemusíme, protože každá funkce má svou vlastní dokumentaci. Ta obsahuje popis funkce, výčet všech jejich argumentů, detaily o jejím fungování a příklady použití. Dokumentaci pro vybranou funkci můžeme zobrazit pomocí funkce help(), případně ?:\n\nhelp(mean)\n?mean\n\nObě výše zmíněné funkce mají stejný výsledek, a to otevření dokumentace pro funkci mean(). Dokumentace všech funkcí má stejnou strukturu, složenou z následujících součástí.\nPrvní sekcí je Description, která obsahuje krátký popis funkce, v tomto případě vysvětlení, že funkce mean() počítá aritmetický průměr.\nV sekci Usage je k vidění výchozí nastavení funkce, vidíme například, že argument trim má výchozí hodnotu 0 a argument na.rm je nastavený na FALSE.\nSekce Arguments nepřekvapivě popisuje jednotlivé argumenty, k čemu slouží a jakých hodnot mohou nabývat.\nNásleduje sekce Value, která popisuje výsledek dané funkce, tedy co dostaname, pokud funkci aplikujeme.\nObčas přítomná je také sekce Details, která poskytuje další detaily o fungování funkce. Tato sekce se objevuje hlavně u funkcí pro výpočet statistických modelů a podobně komplikovanějších funkcí.\nReferences je klasickým seznamem literatury. Najdeme zde všechny texty citované v dokumentaci a odkazy na další užitečné práce.\nSee Also je seznamem příbuzných funkcí, které by uživatele mohli zajímat. Vidíme například, že je nám doporučena funkce weighted.mean() pro výpočet váženého průměru.\nExamples je poslední sekcí dokumentace, která obsahuje ukázky použití funkce v praxi."
  },
  {
    "objectID": "funkce.html#vytváření-vlastních-funkcí",
    "href": "funkce.html#vytváření-vlastních-funkcí",
    "title": "6  Funkce",
    "section": "6.6 Vytváření vlastních funkcí",
    "text": "6.6 Vytváření vlastních funkcí\nJedním z největších předností R je, že se při naší práci nemusíme spoléhat pouze na funkce, které pro nás připravili jiné lidé, ale můžeme si vytvořit funkce na míru naším potřebám. Vytvoření nové funkce je velmi jednoduché, pomocí funkce function.\nFunkci, kterou základní instalace R překvapivě postrádá, je výpočet počtu chybějících hodnot v proměnné. Ne, že by se jednalo o obtížný úkol. Lze k tomu využít kombinaci dvou funkcí, is.na() a sum().\nFunkce is.na() zkontroluje, jestli každý element vektoru chybějící hodnota a vrátí nám nový logický vektor, který bude mít hodnotu TRUE v případě chybějících hodnot a hodnotu FALSE v případě těch platných. Například:\n\nage <- c(NA, 16, 17, NA, 3)\nis.na(age)\n\n[1]  TRUE FALSE FALSE  TRUE FALSE\n\n\nJak vidíme, na první a čtvrtý element jsou chybějící hodnoty. Nyní můžeme použít funkci sum(), který při aplikaci na logický vektor vrátí počet TRUE hodnot:\n\nsum(is.na(age))\n\n[1] 2\n\n\nA opravdu, dozvěděli jsme se, že v našem vektoru jsou dvě chybějící hodnoty. Nabízí se ale otázka, jestli by se kombinace funkcí sum(is.na()) nedala nějak zjednodušit. Přeci jen, počítat chybějící hodnoty budeme relativně často, a čím méně závorek v našem kódu, tím menší šance, že některou z nich zapomeneme uzavřít.\nVytvoříme si proto vlastní funkci, která bude počítat chybějící hodnoty za nás. Taková funkce by mohla vypadat třeba takto:\n\ncount_missings <- function(var) {\n  sum(is.na(var))\n}\n\nJako první musíme naší funkci vymyslet jméno. V tomto případě použijeme popisné count_missings. Novou funkci vytvoříme pomocí funkce function(). Do kulatých závorek vypíšeme, jaké argumenty by naše nová funkce měla mít. V našem případě bude stačit pouze jediný argument, a to var. Následují spojené závorky a uvnitř to hlavní, tedy popis toho, co má naše nová funkce dělat. V tomto případě spočítá počet chybějících hodnot. Všimněte si, že se zde znovu objevu argument var, který jsme definovali v předchozím kroku.\nA to je vše. Teď už můžeme používat naší novou funkci a ušetřit si trochu psaní:\n\ncount_missings(age)\n\n[1] 2"
  },
  {
    "objectID": "balicky.html#instalace-balíčků",
    "href": "balicky.html#instalace-balíčků",
    "title": "7  R balíčky",
    "section": "7.1 Instalace balíčků",
    "text": "7.1 Instalace balíčků\nVětšina balíčků pro R je dostupná v repozitáři zvaném Comprehensive R Archive Network (CRAN). CRAN je spravován centrálním vývojářským týmem R a všechny balíčky v něm podstupují přísnou technickou kontrolu. Ta zajišťuje, že všechny balíčky fungují na všech mainstramových operačních systémech, mají kompletní dokumentaci a neobsahují žádný škodlivý kód (ovšem pozor na to, že CRAN neručí za věcnou správnost funkcí! To, jestli vám statistické a další funkce dají správný výsledek, je zodpovědností jednotlivých autorů). Instalace balíčků z CRAN je jednoduché, stačí použít funkci install.packages():\n\ninstall.packages(\"tidyverse\")\n\nVšimněte si, že název balíčku, který chceme nainstalovat, v tomto případě tidyverse, musí být v úvozovkách. Tatot funkce také automaticky stáhne všechny prerekvizity potřebná pro zvolený balíček.\nFunkci install.packages() je možné použít také k aktualizaci balíčků. Pokaždé, když ji použijete, bude stažena nejnovější dostupná verze zvoleného balíčku. Seznam nainstalovaných balíčkl, pro které jsou dostupné aktuálnější verze, můžeme získat pomocí funkce old.packages() (bez jakkýchkoliv argumentů). Pokud máte zastaralých balíčků více, můžete je aktualizovat všechny najednou pomocí funkce update.packages()."
  },
  {
    "objectID": "balicky.html#nahrání-balíčku",
    "href": "balicky.html#nahrání-balíčku",
    "title": "7  R balíčky",
    "section": "7.2 Nahrání balíčku",
    "text": "7.2 Nahrání balíčku\nPoté co je balíček nainstalován, je před jeho použitím třeba ještě nahrát (“zapnout”). R nenahrává všechny nainstalované balíčky, aby zbytečně neplýtvalo paměti. Nahrát balíček je nutné pokaždé, když restartujete R. Nahrání samotné je jednoduchý proces pomocí funkce library():\n\nlibrary(tidyverse)\n\nVšimněte si, že u funkce library() už název balíčku nemusí být v uvozovkách (ale může, pokud preferujete konzistenci).\n\n\n\n\n\n\ninstall.packages versus library\n\n\n\nZačínající uživatele si občas nejsou jistí rozdílem mezi funkcemi install.packages() a library(), potažmo mezi instalací a nahráním balíčku. Instalace balíčku je proces zahrnující stažení balíčku z internetu a jeho následné nahrání. To je nutné udělat pouze jednou a balíček od té chvíle bude na vašem počítači. Nahráním balíček aktivujete, což vám umožní přístup k jeho funkcím. Nahrávat balíčky je nutné pokaždé, když spustíte R.\n\n\nPokud se během analýzy rozhodnete, že již balíček nepotřebujete, můžete ho vypnout pomocí funkce detach(). Tím přijdete o funkce v něm obsažené, až do chvíle, kdy znovu použijete funkci library(). Pokud chcete balíček odinstalovat úplně, použijte funkci remove.packages(). Ovšem pozor! Tato funkce smaže daný balíček z vašeho počítače. Pokud si své rozhodnutí v budoucnu rozmyslíte, budete si muset balíček znovu stáhnout a nainstalovat."
  },
  {
    "objectID": "balicky.html#konflikty-mezi-balíčky",
    "href": "balicky.html#konflikty-mezi-balíčky",
    "title": "7  R balíčky",
    "section": "7.3 Konflikty mezi balíčky",
    "text": "7.3 Konflikty mezi balíčky\nProtože jsou balíčky pro R vytvářeny nezávisle na sobě velkým množstvím lidí, dostanou se čas od času do vzájemného konfliktu. Nejčastějším konfliktem je, že dva různí autoři použijí pro své funkce stejný název. Příkladem může být balíček dplyr, součást Tidyverse, který obsahuje funkci filter(). Funkce filter() je už ale obsažená v balíčku stats, který je součástí základní instalace. Pokud k situaci je tato dojde, R bude preferovat funkci pocházející z balíčku, který byl nahrán později (v tom případě tedy dplyr). Pokud bychom chtěli využít funkci fitler() z balíčku stats, he nutné specifikovat v jakého balíčku (v odborném žargonu namespace) ji má R hledat, čehož docílíme pomocí :: v tomto formátu:\n\nstats::filter()\n\nAnalogicky, pokud bychom chtěli použít verzi z dplyr, použili bychom dplyr::filter()."
  },
  {
    "objectID": "balicky.html#kde-hledat-balíčky",
    "href": "balicky.html#kde-hledat-balíčky",
    "title": "7  R balíčky",
    "section": "7.4 Kde hledat balíčky",
    "text": "7.4 Kde hledat balíčky\nUž jsme zmínili, že většinu balíčků, které budete potřebovat, je možné získat z CRAN. Kromě něj ale existují i další repozitáře, na kterých vývojáři sdílí svou práci.\nTím nejpolárnějším je dnes Github. Tato stránka je populární nejen u uživatelů R, ale i všech ostatních jazyků. dalšími populárními možnostmi jsou R-forge a, zvláště u kolegů z biologie a chemie, Bioconductor.\nTyto repozitáře se od CRAN liší ve dvou ohledech. Tím prvním je, že balíčky nejsou zdaleka tak přísně kontrolovány, co se týče kvality. To na jednu stranu urychluje proces publikace, na druhou stranu musí být koncoví uživatelé opatrnější ohledně toho, co instalují na svůj počítač. Druhým aspektem je, že instalace z těchto repozitářů zpravidla vyžaduje více kroků, než jen využití install.packages(). Doporučujeme konzultovat dokumentaci k balíčkům v těchto repozitářích. Proces instalace ovšem není o tolik náročnější."
  },
  {
    "objectID": "import-export.html#pracovní-adresář",
    "href": "import-export.html#pracovní-adresář",
    "title": "8  Import a export dat",
    "section": "8.1 Pracovní adresář",
    "text": "8.1 Pracovní adresář\nPředtím, než se pustíme do importu dat samotného, se musíme seznámit s konceptem pracovního adresáře (working directory). Pracovní adresář je výchozí složka na vašem počítači, ze kterého bude R importovat a exportovat všechny soubory, pokud mu neřeknete jinak. Cestu k vašemu současnému pracovnímu adresáři zjistíte pomocí funkce getwd (get working directory):\n\ngetwd()\n\n[1] \"/Users/ales/Documents/cuni/teaching/uvod-do-r-kniha\"\n\n\nV našem případě je pracovním adresářem složka /Users/ales/Documents/phd/teaching/uvod-do-r-kniha. Pokud bychom po R chtěli naimportovat nějaký datový soubor, R ho bude hledat v této složce. Stejně tak, pokud bych exportoval vytvořený graf, bude uložen do této složky. Na koncept pracovního adresáře je dobré si zvyknout rychle, protože mnoho problémů, které začínající uživatelé mají během importu dat, je způsobeno buď odkazováním na špatnou složku nebo neznalostí jejich pracovního adresáře.\n\n\n\n\n\n\nAť se o to postará Rstudio\n\n\n\nJednou z velkých předností Rstudio projektů (viz Sekce 3.1 ) je automatické nastavení pracovního adresáře do kmenové složky vašeho projektu při startu. To zaručuje, že pracovní adresář bude vždy poblíž vašich dat, což výrazně ulehčuje jejich import.\n\n\nVýchozí pracovní adresář (mimo Rstudio projekt) je možné nastavit v Tools -> Global Options -> General. Pracovní adresář je také možné nastavit ručně pomocí funkce setwd(), tuto možnost ale silně nedoporučujeme. Problém spočívá v tom, že jakákoliv adresa na vašem počítači je platná jen pro váš počítač. Pokud byste složku s vaším projektem přesunuli na jiné místo nebo poslali kolegovi, bylo by nutné měnit všechny pracovní adresáře ručně. Mnohem lepší je spoléhat na automatické nastavení pomocí Rstudio projektů."
  },
  {
    "objectID": "import-export.html#import-dat",
    "href": "import-export.html#import-dat",
    "title": "8  Import a export dat",
    "section": "8.2 Import dat",
    "text": "8.2 Import dat\n\n8.2.1 Comma seperated values\nZdaleka nejčastějším typem souborů, se kterými se pravděpodobně setkáte, jsou takzvané comma separated values (CSV) soubory. Ty se dají poznat jednoduše podle koncovky .csv. Data tohoto typu můžeme naimportovat do R pomocí funkce read_csv() z balíčku readr, která je také součástí balíčku tidyverse.\nMožnosti, jak říct R, kde má soubor hledat, jsou dvě. Tou preferovanou je využít relativní cesty (relative path). Relativní cesta začíná ve vašem pracovní adresáři a můžeme jít specifikovat následovně:\n\nlibrary(tidyverse) # nezapomeňte na nahrání balíčku!\n\ncountries <- read_csv(\"data-raw/countries.csv\")\n\nTento příkaz říká R, aby se v pracovním adresáři podívalo do složky data-raw a v ní hledalo soubor countries.csv. Nalezený soubor potom naimportuje jako dataframe a pojmenuje countries.\nAlternativně je možné specifikovat úplnou cestu k souboru (full path):\n\ncountries <- read_csv(\"/Users/ales/Documents/phd/teaching/uvod-do-r-kniha/data-raw/countries.csv\")\n\nOproti předchozímu příkladu je plná cesta mnohem delší. Silně doporučujeme plné cesty nevyužívat, a to ze stejného důvodu, ze kterého byste neměli ručně nastavovat pracovní adresáře. Výše uvedená cesta bude fungovat pouze na jednom konkrétním počítači a pouze dokud zůstane složka s projektem na stejném místě. Používáním plných cest si zaděláváte na problém ve chvíli, kdy budete přesouvat svoji práci z jednoho počítače na druhý.\n\n\n\n\n\n\nread_csv versus read.csv\n\n\n\nPro import dat do R není nezbytně nutné využívat balíček readr, potažmo tidyverse. Základní instalace R obsahuje funkci read.csv(), pomocí které byste mohli data importovat stejným způsobem. My ale preferujeme read_csv(), protože je rychlejší a dává nám větší kontrolu nad tím, jak jsou data importována.\n\n\nData lze stejným způsobem stahovat i z internetu:\n\ncountries <- read_csv(\"https://raw.githubusercontent.com/Sociology-FA-CU/Uvod_do_analyzy_dat_v_R/master/data/countries.csv\")\n\nBohužel, ne všechna data uložená ve formátu .csv jsou opravdu hodnoty oddělené čárkami. Přestože tyto atypické formáty mohou vzniknout více způsoby, primárním zdrojem problémů je většinou Microsoft Excel. Ten je distribuován v řadě regionálních verzí, z nichž každá se chová trochu jinak. Konkrétně verze pro střední Evropu využívá pro oddělování hodnot středníky (;), protože středoevropské země historicky využívají čárku pro oddělení desetinných míst. To vede k řadě otravných problému při importu a exportu dat, zvláště v mezinárodních týmech.\nV případě, že se setkáte s datovým souborem, který nepoužívá klasické oddělovače, máte dvě možnosti. Tou první je pomocí argumentů funkce read_csv() ručně upravit, které hodnoty mají být viděni jako oddělovače sloupců a které jako oddělovače desetinných míst. Například:\n\ncountries <- read_csv(\"data-raw/countries.csv\",\n                      locale = locale(grouping_mark = \";\",\n                                      decimal_mark = \",\"))\n\nProtože problémy s importem dat produkovaných ve střední Evropě jsou extrémně časté, balíček readr obsahuje funkci read_csv2(), která plní stejný účel jako kód výše. Druhou možností je tedy ulehčit si psaní a využít ji:\n\ncountries <- read_csv2(\"data-raw/countries.csv\")\n\n\n\n\n\n\n\nPeklo jménem locale encoding\n\n\n\nKromě problému s oddělovači se při práci s neanglickým textem setkáte pravděpodobně ještě s jedním problémem: nesprávným zobrazením českých znaků (resp. znaků, které nejsou obsaženy v anglosaské abecedě). Uchovávání textu ve výpočetní technice je komplexním problémem, pro který existuje velké množství standardů. Autoři většiny operačních systémů, včetně Linuxu a MacOS, se dnes již shodli na využívání univerzálního standardu zvaného UTF-8. Ne tak ovšem Microsoft a Windows využívá několik desítek standardů v závislosti na regionální verzi operačního systému. To vede k problémům při analýze dat, jelikož data vytvořená na jedné regionální verzi Windows se nemusí zobrazit správně na jiné regionální verzi (nebo jiném operačním systému). Pokud k tomu dojde, je nutné specifikovat standard kódování textu (locale encoding) manuálně. V českém prostředí se nejčastěji setkáme s encodingem Windows-1252, import dat by tedy vypadal následovně\n\ncountries <- read_csv(\"data-raw/countries.csv\",\n                      locale = locale(encoding = \"Windows-1252\"))\n\nDalšími populárními verzemi je Windows-1250, případně již zmiňovaný UTF-8. Pokud žádná z těchto možností nepovede ke správnému importu dat, bůh vám pomáhej. Seznam existujících standardů je dostupný na Wikipedii.\n\n\n\n\n8.2.2 RDS\nFormát .rds je specifický pro R. Na rozdíl od .csv souborů, .rds formát uchovává také metadata, jako je například pořadí kategorií ve faktoru nebo atributy proměnných v dataframu. Import těchto souborů je velmi podobný importu tomu, co jsme již viděli:\n\ncountries <- read_rds(\"data-raw/countries.rds\")\n\n.rds soubory nemusí obsahovat pouze jednoduchá tabulková data, ale i složitější objekty, jako jsou listy. Hodí se proto například pro ukládání vytvořených statistických modelů.\n\n\n8.2.3 SPSS a Stata\nPoměrně velké množství sociálněvědních dat je uloženo ve formátech vlastních SPSS a Stata, jelikož tyto programy dlouhou dobu dominovali v akademickém prostředí. Základní instalace R neobsahuje funkce, pomocí kterých bychom mohli data v tomto formátu naimportovat, naštěstí ale pro tento účel existuje několik šikovných balíčků. Jedním z nich je balíček haven. Pro import dat vytvořených v SPSS:\n\ncountries <- read_spss(\"data-raw/countries.sav\") # funkce z balíčku haven\n\nAnalogicky, pro import dat ze programu Stata:\n\ncountries <- read_stata(\"data-raw/countries.dta\")"
  },
  {
    "objectID": "import-export.html#export-dat",
    "href": "import-export.html#export-dat",
    "title": "8  Import a export dat",
    "section": "8.3 Export dat",
    "text": "8.3 Export dat\nExport dat probíhá velmi podobně, jako jejich import. Zatímco importovací funkce začínají slovesem read_, exportovací naopak write_. Například pro export ve formátu .csv do do složky data-clean v našem pracovním adresáři:\n\nwrite_csv(x = countries, file = \"data-clean/countries.csv\")\n\nVšimněte si, že při exportu dat nepřiřazujeme výsledku funkce žádné jméno, protože nevytváříme nový objekt uvnitř R. Místo toho pomocí argumentu x specifikujeme, které objekt chceme exportovat, a pomocí argumentu file poté kam a pod jakým jménem. Analogicky bychom mohli využít funkce write_rds(), write_sav (pro export do SPSS formátu) a write_dta() (pro export od Stata).\n\n\n\n\n\n\nPozor na lomítka\n\n\n\nPokud používáte Windows, dejte si pozor na lomítka v cestách k souborům. R očekává, že budete používat forward-slash (/), tedy například project/data-raw/countries.csv. Naopak Windows používá v cestách back-slash (\\) a cesta by tedy vypadal následovně project\\data-raw\\countries.csv. Při práci v R je nutné používat / pokud cestu kopírujete odjinud, je nutné lomítka ručně opravit. Uživatelé ostatních operačních systémů se patáliemi s lomítky nemusí trápit."
  },
  {
    "objectID": "dataframe.html#pohled-na-dataframe",
    "href": "dataframe.html#pohled-na-dataframe",
    "title": "9  První pohled na dataframe",
    "section": "9.1 Pohled na dataframe",
    "text": "9.1 Pohled na dataframe\nJako první je dobré se ujistit, že data byla importována správně. Dataframe je možné si prohlédnout pomocí View() (pozor, s velkým V!):\n\nView(countries)\n\n\n\n\nPohled na náš dataframe\n\n\nView() zobrazí dataframe v novém interaktivním okně, pomocí kterého lze zkontrolovat, jestli byla data nahrána správně, jestli jsou proměnné správně pojmenované a všechen text se zobrazuje bez problémů. U větších dat může být ovšem funkce být poněkud pomalá. Lepší je proto podívat se pouze na výsek dat. Funkce head() umožňuje zobrazit několik prvních řádků dataframu (a analogicky funkce tail() zobrazí poslední řádky):\n\nhead(countries, n = 3)\n\n# A tibble: 3 × 17\n  country  code      gdp popula…¹   area eu_me…² posts…³ life_…⁴ uni_prc pover…⁵\n  <chr>    <chr>   <dbl>    <dbl>  <dbl> <chr>   <chr>     <dbl>   <dbl>   <dbl>\n1 Belgium  BE    450506. 11398589  30528 yes     no         81.2   0.36    0.203\n2 Bulgaria BG     55182.  7050034 110879 yes     yes        74.8   0.248   0.389\n3 Czechia  CZ    207772. 10610055  78867 yes     yes        79.2   0.217   0.122\n# … with 7 more variables: material_dep <dbl>, hdi <dbl>,\n#   foundation_date <date>, maj_belief <chr>, dem_index <dbl>, di_cat <chr>,\n#   hd_title_name <chr>, and abbreviated variable names ¹​population,\n#   ²​eu_member, ³​postsoviet, ⁴​life_exp, ⁵​poverty_risk\n\n\nPoslední možností je vytisknout dataframe přímo do konzole, což však s vyjímkou velmi malých dat není příliš přehledné."
  },
  {
    "objectID": "dataframe.html#sumarizace-dataframu",
    "href": "dataframe.html#sumarizace-dataframu",
    "title": "9  První pohled na dataframe",
    "section": "9.2 Sumarizace dataframu",
    "text": "9.2 Sumarizace dataframu\nBalíček dplyr z Tidyverse nabízí o něco kompaktnější funkci pro prohlédnutí našich dat, glimpse():\n\nglimpse(countries)\n\nRows: 38\nColumns: 17\n$ country         <chr> \"Belgium\", \"Bulgaria\", \"Czechia\", \"Denmark\", \"Germany\"…\n$ code            <chr> \"BE\", \"BG\", \"CZ\", \"DK\", \"DE\", \"EE\", \"IE\", \"GR\", \"ES\", …\n$ gdp             <dbl> 450505.7, 55182.2, 207772.4, 298276.5, 3386000.0, 2565…\n$ population      <dbl> 11398589, 7050034, 10610055, 5781190, 82792351, 131913…\n$ area            <dbl> 30528, 110879, 78867, 43094, 357022, 45228, 70273, 131…\n$ eu_member       <chr> \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\", \"yes\"…\n$ postsoviet      <chr> \"no\", \"yes\", \"yes\", \"no\", \"yes\", \"yes\", \"no\", \"no\", \"n…\n$ life_exp        <dbl> 81.2, 74.8, 79.2, 81.2, 81.0, 77.8, 81.5, 81.2, 83.1, …\n$ uni_prc         <dbl> 0.360, 0.248, 0.217, 0.327, 0.252, 0.359, 0.405, 0.277…\n$ poverty_risk    <dbl> 0.203, 0.389, 0.122, 0.172, 0.190, 0.234, 0.227, 0.348…\n$ material_dep    <dbl> 0.113, 0.438, 0.098, 0.068, 0.091, 0.116, 0.148, 0.360…\n$ hdi             <dbl> 0.92, 0.81, 0.89, 0.93, 0.94, 0.87, 0.94, 0.87, 0.89, …\n$ foundation_date <date> 1831-07-21, 1989-11-10, 1993-01-01, 2053-05-19, 1949-…\n$ maj_belief      <chr> \"catholic\", \"orthodox\", \"nonbelief\", \"protestantism\", …\n$ dem_index       <dbl> 7.78, 7.03, 7.69, 9.22, 8.68, 7.97, 9.15, 7.29, 8.08, …\n$ di_cat          <chr> \"Flawed democracy\", \"Flawed democracy\", \"Flawed democr…\n$ hd_title_name   <chr> \"King - Philippe\", \"President - Rumen Radev\", \"Preside…\n\n\nAlternativní možností je generická funkce summary():\n\nsummary(countries)\n\n   country              code                gdp            population      \n Length:38          Length:38          Min.   :  10735   Min.   :   38114  \n Class :character   Class :character   1st Qu.:  43947   1st Qu.: 2075301  \n Mode  :character   Mode  :character   Median : 201612   Median : 7001444  \n                                       Mean   : 484601   Mean   :16754743  \n                                       3rd Qu.: 458715   3rd Qu.:11398589  \n                                       Max.   :3386000   Max.   :82792351  \n                                       NA's   :3         NA's   :1         \n      area         eu_member          postsoviet           life_exp    \n Min.   :   160   Length:38          Length:38          Min.   :74.80  \n 1st Qu.: 41344   Class :character   Class :character   1st Qu.:76.80  \n Median : 73874   Mode  :character   Mode  :character   Median :81.00  \n Mean   :156019                                         Mean   :79.58  \n 3rd Qu.:242305                                         3rd Qu.:81.60  \n Max.   :783562                                         Max.   :83.30  \n                                                        NA's   :1      \n    uni_prc        poverty_risk     material_dep         hdi        \n Min.   :0.1550   Min.   :0.1220   Min.   :0.0420   Min.   :0.7600  \n 1st Qu.:0.2200   1st Qu.:0.1770   1st Qu.:0.0820   1st Qu.:0.8425  \n Median :0.3010   Median :0.2200   Median :0.1280   Median :0.8800  \n Mean   :0.2915   Mean   :0.2403   Mean   :0.1799   Mean   :0.8739  \n 3rd Qu.:0.3630   3rd Qu.:0.2820   3rd Qu.:0.2590   3rd Qu.:0.9200  \n Max.   :0.4050   Max.   :0.4160   Max.   :0.4810   Max.   :0.9500  \n NA's   :3        NA's   :5        NA's   :5                        \n foundation_date       maj_belief          dem_index        di_cat         \n Min.   :1291-08-01   Length:38          Min.   :4.370   Length:38         \n 1st Qu.:1919-11-11   Class :character   1st Qu.:6.670   Class :character  \n Median :1975-06-01   Mode  :character   Median :7.710   Mode  :character  \n Mean   :1930-10-08                      Mean   :7.639                     \n 3rd Qu.:1991-08-28                      3rd Qu.:8.680                     \n Max.   :2053-05-19                      Max.   :9.870                     \n                                         NA's   :1                         \n hd_title_name     \n Length:38         \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n                   \n\n\nV některých případech nepotřebujeme prohlížet celý dataframe. Pokud si nejsme jistí, jak se jmenují proměnné v našem dataframu, pomůžeme nám funkce names():\n\nnames(countries)\n\n [1] \"country\"         \"code\"            \"gdp\"             \"population\"     \n [5] \"area\"            \"eu_member\"       \"postsoviet\"      \"life_exp\"       \n [9] \"uni_prc\"         \"poverty_risk\"    \"material_dep\"    \"hdi\"            \n[13] \"foundation_date\" \"maj_belief\"      \"dem_index\"       \"di_cat\"         \n[17] \"hd_title_name\"  \n\n\nCelkový počet proměných lze zjistit pomocí funkce ncol(), případně length(), pro kontrolu počtu řádků potom příbuzná nrow():\n\nncol(countries)\n\n[1] 17\n\nnrow(countries)\n\n[1] 38"
  },
  {
    "objectID": "sloupce.html#výběr-sloupců",
    "href": "sloupce.html#výběr-sloupců",
    "title": "10  Práce se sloupci",
    "section": "10.1 Výběr sloupců",
    "text": "10.1 Výběr sloupců\nPředmětem analýzy v mnoha případech není celý dataframe, ale pouze jeho výsek. Základní aplikace již zmíněné funkce select() je přímočará. Prvním argumentem je dataframe, který chceme filtrovat, zbylými sloupce, které chceme zachovat:\n\nselect(countries, country, life_exp, postsoviet)\n\n# A tibble: 38 × 3\n   country  life_exp postsoviet\n   <chr>       <dbl> <chr>     \n 1 Belgium      81.2 no        \n 2 Bulgaria     74.8 yes       \n 3 Czechia      79.2 yes       \n 4 Denmark      81.2 no        \n 5 Germany      81   yes       \n 6 Estonia      77.8 yes       \n 7 Ireland      81.5 no        \n 8 Greece       81.2 no        \n 9 Spain        83.1 no        \n10 France       82.9 no        \n# … with 28 more rows\n\n\nPokud by naším cílem bylo se některého sloupce zbavit, využijeme mínusu (-), podobně jako u indexování (viz. Sekce 6.3 ). Pro vyřazení více sloupců využijeme již dobře známou funkci c():\n\nselect(countries, -c(country, life_exp, postsoviet))\n\n# A tibble: 38 × 14\n   code      gdp popul…¹   area eu_me…² uni_prc pover…³ mater…⁴   hdi foundati…⁵\n   <chr>   <dbl>   <dbl>  <dbl> <chr>     <dbl>   <dbl>   <dbl> <dbl> <date>    \n 1 BE     4.51e5  1.14e7  30528 yes       0.36    0.203   0.113  0.92 1831-07-21\n 2 BG     5.52e4  7.05e6 110879 yes       0.248   0.389   0.438  0.81 1989-11-10\n 3 CZ     2.08e5  1.06e7  78867 yes       0.217   0.122   0.098  0.89 1993-01-01\n 4 DK     2.98e5  5.78e6  43094 yes       0.327   0.172   0.068  0.93 2053-05-19\n 5 DE     3.39e6  8.28e7 357022 yes       0.252   0.19    0.091  0.94 1949-05-23\n 6 EE     2.57e4  1.32e6  45228 yes       0.359   0.234   0.116  0.87 1918-02-24\n 7 IE     3.24e5  4.83e6  70273 yes       0.405   0.227   0.148  0.94 1937-12-29\n 8 GR     1.85e5  1.07e7 131957 yes       0.277   0.348   0.36   0.87 1975-11-19\n 9 ES     1.21e6  4.67e7 505370 yes       0.34    0.266   0.128  0.89 1978-12-06\n10 FR     2.35e6  6.69e7 643801 yes       0.328   0.171   0.111  0.9  1958-10-05\n# … with 28 more rows, 4 more variables: maj_belief <chr>, dem_index <dbl>,\n#   di_cat <chr>, hd_title_name <chr>, and abbreviated variable names\n#   ¹​population, ²​eu_member, ³​poverty_risk, ⁴​material_dep, ⁵​foundation_date"
  },
  {
    "objectID": "sloupce.html#sec-helpers",
    "href": "sloupce.html#sec-helpers",
    "title": "10  Práce se sloupci",
    "section": "10.2 Pomocné funkce",
    "text": "10.2 Pomocné funkce\nRučně vypisovat všechny proměnné, které chceme vybrat, je u větších dataframů zdlouhavá činnost. Naštěstí pro nás obsahuje balíček dplyr řadu pomocných funkcí (selection helpers).\nNejzákladnější pomocnou funkcí je :, která vybere všechny sloupce v rozpětí. Například, pro vybrání country, area a všech proměnných mezi nimi:\n\nselect(countries, country:area)\n\nPokud chceme vybrat všechny proměnné v dataframu, nemusíme využívat :, stačí využít funkci everything(). Možnost vybrat úplně všechny proměnné se nemusí zdát na první pohled užitečná, nachází ale často využití při převodu dat mezi širokým a dlouhým formátem (viz. níže).\nSadou užitečných pomocných funkcí jsou starts_with(), ends_with() a contains(). Funkce starts_with() vybere všechny sloupce začínající stejnými znaky, ends_with() naopak všechny sloupce končící stejně. contains() identifikuje sloupce, jejichž název obsahuje specifikovaný řetězec znaků. Například pro vybrání všech proměnných, jejichž název obsahuje podtržítko:\n\nselect(countries, contains(\"_\"))\n\nPoslední pomocnou funkcí, kterou si zde ukážeme, je where(). Pomocí ní lze vybrat všechny sloupce splňující danou logickou podmínku. Pro vybrání všech numerických proměnných:\n\nselect(countries, where(is.numeric))\n\nAnalogicky by bylo možné aplikovat funkce is.character, is.factor nebo is.logical. Tyto funkce jsou uvnitř where() použity bez závorek.\nDokumentace k pomocným funkcím je dostupná pomocí help(\"tidyr_tidy_select\")."
  },
  {
    "objectID": "sloupce.html#přejmenovávání-proměnných",
    "href": "sloupce.html#přejmenovávání-proměnných",
    "title": "10  Práce se sloupci",
    "section": "10.3 Přejmenovávání proměnných",
    "text": "10.3 Přejmenovávání proměnných\nNe vždy budeme spokojeni s tím, jak jsou naše proměnné pojmenované. Způsobů, jak proměnnou přejmenovat je řada, preferovanou metodou v v rámci Tidyverse je využít funkci rename(). Její aplikace je jednoduchá, nové jméno je vždy specifikované ve formátu nove_jmeno = stare_jmeno. Pokud by se nám například nelíbilo jméno proměnné uni_prc, můžeme ho změnit na výstižnější university_educated. Tady poprvé narážíme na řetězení funcí pomocí pipes, představených v kapitole věnované funkcím (Sekce 6.4):\n\ncountries %>% \n  rename(university_educated = uni_prc) %>% \n  select(country, university_educated)\n\n# A tibble: 38 × 2\n   country  university_educated\n   <chr>                  <dbl>\n 1 Belgium                0.36 \n 2 Bulgaria               0.248\n 3 Czechia                0.217\n 4 Denmark                0.327\n 5 Germany                0.252\n 6 Estonia                0.359\n 7 Ireland                0.405\n 8 Greece                 0.277\n 9 Spain                  0.34 \n10 France                 0.328\n# … with 28 more rows\n\n\nDataframe countries již není obsažen ve funkci filter(), ale je do ní poslán skrze pipe (%>%). Vzpomeňme si, že pipe vezme objekt na její levé straně a vloží ho do prvního argumentu funkce napravo.\nO něco komplexnější funkcí je rename_with(). Ta umožňuje přejmenovávat proměnné funkce programátorsky. Co kdybychom například chtěli převést názvy proměnných ze snake_case na kebab-case? Jediné, co pro to musíme udělat je změnit podtržítka v názvech proměnných na pomlčky. Jednou možností by bylo ručně přepsat názvy všech proměnných. Efektivnější variantou je využít funkce rename_with() v kombinaci s funkcí str_replace():\n\ncountries %>% \n  rename_with(str_replace, pattern = \"_\", replacement = \"-\") %>% \n  select(country, contains(\"-\"))\n\n# A tibble: 38 × 11\n   country  eu-memb…¹ life-…² uni-p…³ pover…⁴ mater…⁵ foundati…⁶ maj-b…⁷ dem-i…⁸\n   <chr>    <chr>       <dbl>   <dbl>   <dbl>   <dbl> <date>     <chr>     <dbl>\n 1 Belgium  yes          81.2   0.36    0.203   0.113 1831-07-21 cathol…    7.78\n 2 Bulgaria yes          74.8   0.248   0.389   0.438 1989-11-10 orthod…    7.03\n 3 Czechia  yes          79.2   0.217   0.122   0.098 1993-01-01 nonbel…    7.69\n 4 Denmark  yes          81.2   0.327   0.172   0.068 2053-05-19 protes…    9.22\n 5 Germany  yes          81     0.252   0.19    0.091 1949-05-23 cathol…    8.68\n 6 Estonia  yes          77.8   0.359   0.234   0.116 1918-02-24 nonbel…    7.97\n 7 Ireland  yes          81.5   0.405   0.227   0.148 1937-12-29 cathol…    9.15\n 8 Greece   yes          81.2   0.277   0.348   0.36  1975-11-19 orthod…    7.29\n 9 Spain    yes          83.1   0.34    0.266   0.128 1978-12-06 cathol…    8.08\n10 France   yes          82.9   0.328   0.171   0.111 1958-10-05 cathol…    7.8 \n# … with 28 more rows, 2 more variables: `di-cat` <chr>, `hd-title_name` <chr>,\n#   and abbreviated variable names ¹​`eu-member`, ²​`life-exp`, ³​`uni-prc`,\n#   ⁴​`poverty-risk`, ⁵​`material-dep`, ⁶​`foundation-date`, ⁷​`maj-belief`,\n#   ⁸​`dem-index`"
  },
  {
    "objectID": "sloupce.html#pořadí-proměnných",
    "href": "sloupce.html#pořadí-proměnných",
    "title": "10  Práce se sloupci",
    "section": "10.4 Pořadí proměnných",
    "text": "10.4 Pořadí proměnných\nPořadí proměnných v dataframu je možné upravovat pomocí funkce relocate(). Tu je možné využít pro jednotlivé proměnné i v kombinaci s pomocnými funkcemi. Pomocí argumentů .before a .after je možné určit novu pozici nových sloupců. Pokud bychom chtěli oddělit numerické proměnné od kategoriálních, využijeme následující kombinací funkcí:\n\nrelocate(countries, where(is.numeric), .after = last_col())\n\n# A tibble: 38 × 17\n   country  code  eu_member postsoviet foundatio…¹ maj_b…² di_cat hd_ti…³    gdp\n   <chr>    <chr> <chr>     <chr>      <date>      <chr>   <chr>  <chr>    <dbl>\n 1 Belgium  BE    yes       no         1831-07-21  cathol… Flawe… King -… 4.51e5\n 2 Bulgaria BG    yes       yes        1989-11-10  orthod… Flawe… Presid… 5.52e4\n 3 Czechia  CZ    yes       yes        1993-01-01  nonbel… Flawe… Presid… 2.08e5\n 4 Denmark  DK    yes       no         2053-05-19  protes… Full … Queen … 2.98e5\n 5 Germany  DE    yes       yes        1949-05-23  cathol… Full … Presid… 3.39e6\n 6 Estonia  EE    yes       yes        1918-02-24  nonbel… Flawe… Presid… 2.57e4\n 7 Ireland  IE    yes       no         1937-12-29  cathol… Full … Presid… 3.24e5\n 8 Greece   GR    yes       no         1975-11-19  orthod… Flawe… Presid… 1.85e5\n 9 Spain    ES    yes       no         1978-12-06  cathol… Full … King -… 1.21e6\n10 France   FR    yes       no         1958-10-05  cathol… Flawe… Presid… 2.35e6\n# … with 28 more rows, 8 more variables: population <dbl>, area <dbl>,\n#   life_exp <dbl>, uni_prc <dbl>, poverty_risk <dbl>, material_dep <dbl>,\n#   hdi <dbl>, dem_index <dbl>, and abbreviated variable names\n#   ¹​foundation_date, ²​maj_belief, ³​hd_title_name"
  },
  {
    "objectID": "radky.html#filtrování-řádků",
    "href": "radky.html#filtrování-řádků",
    "title": "11  Práce s řádky",
    "section": "11.1 Filtrování řádků",
    "text": "11.1 Filtrování řádků\nPro filtrování řádků je třeba trocha výrokové logiky. Základními logickými operátory v R jsou == (EQUAL), | (OR) a & (AND). Nepřekvapivě, pro HIGHER THAN používám >=, naopak pro LOWER THAN slouží <=. Negace se provádí pomocí vykřičníku, tedy například NOT EQUAL je !=.\nVybaveni těmito znalostmi, filtrování řádků není obtížný úkol. Hlavní funkcí je zde filter():\n\nfilter(countries, postsoviet == \"yes\" & gdp > 100000)\n\n# A tibble: 5 × 17\n  country code       gdp popula…¹   area eu_me…² posts…³ life_…⁴ uni_prc pover…⁵\n  <chr>   <chr>    <dbl>    <dbl>  <dbl> <chr>   <chr>     <dbl>   <dbl>   <dbl>\n1 Czechia CZ     207772. 10610055  78867 yes     yes        79.2   0.217   0.122\n2 Germany DE    3386000  82792351 357022 yes     yes        81     0.252   0.19 \n3 Hungary HU     131935.  9778371  93028 yes     yes        76     0.217   0.256\n4 Poland  PL     496462. 37976687 312685 yes     yes        77.8   0.272   0.195\n5 Romania RO     202884. 19530631 238391 yes     yes        75.2   0.155   0.357\n# … with 7 more variables: material_dep <dbl>, hdi <dbl>,\n#   foundation_date <date>, maj_belief <chr>, dem_index <dbl>, di_cat <chr>,\n#   hd_title_name <chr>, and abbreviated variable names ¹​population,\n#   ²​eu_member, ³​postsoviet, ⁴​life_exp, ⁵​poverty_risk\n\n\nPodmínky filtrování lze kombinovat, například vyfiltrovat pouze postsovětské země s hrubým domácím produktem větším než 100 000 miliónů euro.\n\n\n\n\n\n\n%in% místo |\n\n\n\nObčas je naším cílem vyfiltrovat řádky obsahující některou z vybraných hodnot kategoriální proměnné, například všechny náboženské skupiny spadající pod křesťanství. Jednou možností je:\n\nfilter(countries, maj_belief == \"catholic\" | maj_belief == \"orthodox\" | maj_belief == \"protestantism\")\n\nTento přístup funguje, je ale zbytečně květnatý. Místo něj je možné aplikovat operátor %in%, pomocí kterého můžeme vyfiltrovat všechny hodnoty objevující se ve zvoleném vektoru:\n\nfilter(countries, maj_belief %in% c(\"catholic\", \"orthodox\", \"protestantism\"))\n\nOba tyto příkazy vedou ke stejnému výsledku, ten druhý je ale výrazně kompaktnější.\n\n\nJak si jistě dokážete představit, funkce select() a filter() jsou často využívané dohromady:\n\ncountries %>% \n  filter(postsoviet == \"yes\") %>% \n  select(country, postsoviet, life_exp)\n\n# A tibble: 16 × 3\n   country                postsoviet life_exp\n   <chr>                  <chr>         <dbl>\n 1 Bulgaria               yes            74.8\n 2 Czechia                yes            79.2\n 3 Germany                yes            81  \n 4 Estonia                yes            77.8\n 5 Croatia                yes            78.3\n 6 Latvia                 yes            75  \n 7 Lithuania              yes            75  \n 8 Hungary                yes            76  \n 9 Poland                 yes            77.8\n10 Romania                yes            75.2\n11 Slovenia               yes            80.9\n12 Slovakia               yes            77.4\n13 North Macedonia        yes            75.9\n14 Albania                yes            76.4\n15 Serbia                 yes            76.3\n16 Bosnia and Herzegovina yes            77.3"
  },
  {
    "objectID": "radky.html#řezání-dataframů",
    "href": "radky.html#řezání-dataframů",
    "title": "11  Práce s řádky",
    "section": "11.2 Řezání dataframů",
    "text": "11.2 Řezání dataframů\nV některých případech budeme chtít filtrovat na základě pořadí řádků dataframů. K tomu nám poslouží rodina funkcí slice z balíčku dplyr.\nPrvním členem této rodiny je funkce slice(). Její aplikace je velmi podobná klasickému indexování pomocí hranatých závorek. Například výběr prvního řádku v dataframu:\n\nslice(countries, 1)\n\nJe ekvivalentní countries[1, ] a vrátí první řádek dataframu. Obdobně podobné jsou i funkce slice(countries, -1) a countries[-1, ], které vrátí všechny řádky kromě prvního. Funkce slice() je však pouze základem pro řadu dalších užitečných funkcí.\nDalší dvě funkce, které nám již svým fungováním budou povědomé jsou slice_head() a slice_tail(). Ty, obdobně jako funkce head() a tail(), vrátí prvních n řádků v dataframů. Na rozdíl od svých příbuzných ze základní instalace R, ovšem slice funkce umožňují vybrat nejen absolutní, ale i relativní počet řádků. Například pro vybrání prvních deseti procent dataframu:\n\nslice_head(countries, prop = 0.1)\n\nPro vybrání absolutního počtu řádku slouží argument n.\nO něco zajímavější jsou funkce slice_max() a slice_min(). Ty umožňují vybrat n řádků s nejvyšší, respektive nejnižší, hodnou dané proměnné. Pomocí těchto funkcí můžeme například jednoduše zjistit, které tři země v našem dataframu mají nejvyšší naději na dožití:\n\nslice_max(countries, order_by = life_exp, n = 3) %>% \n  select(country, life_exp)\n\n# A tibble: 3 × 2\n  country     life_exp\n  <chr>          <dbl>\n1 Switzerland     83.3\n2 Spain           83.1\n3 France          82.9\n\n\na které naopak nejnižší:\n\nslice_min(countries, order_by = life_exp, n = 3) %>% \n  select(country, life_exp)\n\n# A tibble: 3 × 2\n  country   life_exp\n  <chr>        <dbl>\n1 Bulgaria      74.8\n2 Latvia        75  \n3 Lithuania     75  \n\n\nFunkce slice_max() a slice_min() jsem zde zkombinovaly s funkcí select(), abychom vybrali jen relevantní proměnné.\nPosledním členem rodiny je funkce slice_sample(), která vybere náhodné řádky dataframu. Tato funkce najde uplatnění zejména v simulačních studiích a technikách.\n\nslice_sample(countries, n = 3)"
  },
  {
    "objectID": "radky.html#sec-group-by",
    "href": "radky.html#sec-group-by",
    "title": "11  Práce s řádky",
    "section": "11.3 Group_by()",
    "text": "11.3 Group_by()\nV tuto chvíli si možná někteří čtenáři říkají, jaké je využití slice funkcí oproti jejich klasickým variantám, jako je head() nebo tail(). Jednou z jejich velkých předností je možnost kombinovat je s funkcí group_by().\nFunkce group_by() umožňuje rozdělit dataframe na podskupiny a aplikovat funkce z balíčku dplyr na každou z podskupin zvlášť. Podskupiny jsou definované kategorickou proměnnou v dataframu. Tímto způsobem můžeme zjistit nejen které země se těší nejvyšší naději na dožití obecně, ale i to, jak jsou na tom západní a postsovětské země zvlášť:\n\ncountries %>% \n  group_by(postsoviet) %>% \n  slice_max(order_by = life_exp, n = 3) %>% \n  select(country, postsoviet, life_exp)\n\n# A tibble: 6 × 3\n# Groups:   postsoviet [2]\n  country     postsoviet life_exp\n  <chr>       <chr>         <dbl>\n1 Switzerland no             83.3\n2 Spain       no             83.1\n3 France      no             82.9\n4 Germany     yes            81  \n5 Slovenia    yes            80.9\n6 Czechia     yes            79.2\n\n\nZatímco mezi západními zeměmi vedou Švýcarsko, Španělsko a Francie, v postsovětské skupině je to Německo, Slovinsko a Česká republika. Třídit je možné i pomocí většího počtu proměnných, například pro třídění podle postsovětské historie a členství v Evropské unii bychom použili group_by(postsoviet, eu_member). Jak jistě tušíte, funkce group_by() má mnoho využití a budeme se s ní setkávat opakovaně i následujících kapitolách."
  },
  {
    "objectID": "radky.html#pořadí-řádků",
    "href": "radky.html#pořadí-řádků",
    "title": "11  Práce s řádky",
    "section": "11.4 Pořadí řádků",
    "text": "11.4 Pořadí řádků\nPosledním typem operace, kterou si v této kapitole představíme, je řazení řádků pomocí funkce arrange(). Pořadí zemí v dataframu countries podle naděje na dožití získáme jednoduše:\n\ncountries %>% \n  arrange(life_exp) %>% \n  select(country, life_exp)\n\n# A tibble: 38 × 2\n   country         life_exp\n   <chr>              <dbl>\n 1 Bulgaria            74.8\n 2 Latvia              75  \n 3 Lithuania           75  \n 4 Romania             75.2\n 5 North Macedonia     75.9\n 6 Hungary             76  \n 7 Serbia              76.3\n 8 Albania             76.4\n 9 Turkey              76.4\n10 Montenegro          76.8\n# … with 28 more rows\n\n\nPři bližším pohledu zjistíme, že země jsou seřazený vzestupně. Nejhůře se vede Bulhrasko a Litva s Lotyšskem. Co kdyby nás ale zajímaly země s nejvyšší nadějí na dožití? Pro sestupné řazení zkombinujeme funkci arrange() s funkcí des():\n\ncountries %>% \n  arrange(desc(life_exp)) %>% \n  select(country, life_exp)\n\n# A tibble: 38 × 2\n   country     life_exp\n   <chr>          <dbl>\n 1 Switzerland     83.3\n 2 Spain           83.1\n 3 France          82.9\n 4 Italy           82.8\n 5 Norway          82.5\n 6 Luxembourg      82.4\n 7 Sweden          82.4\n 8 Iceland         82.4\n 9 Austria         81.9\n10 Netherlands     81.6\n# … with 28 more rows\n\n\nNejvyšší naději na dožití se těší Švýcarsko, se Španělskem v těsném závěsu."
  },
  {
    "objectID": "siroky-dlouhy-format.html#z-širokého-do-dlouhého-formátu",
    "href": "siroky-dlouhy-format.html#z-širokého-do-dlouhého-formátu",
    "title": "12  Široký a dlouhý formát",
    "section": "12.1 Z širokého do dlouhého formátu",
    "text": "12.1 Z širokého do dlouhého formátu\nVraťme se k datasetu countries. V rámci analýzy nás může zajímat, jaká je nejvyšší pozorovaná hodnota každé z numerických proměnné. Jako bonus bychom také rádi věděli, které zemi tato hodnota patří.\nMožností, jak se dostat ke kýženému výsledku, je více. Jedna z těch elegantnějších zahrnuje převedení dataframu do dlouhého formátu. Začneme tím, že z dataframu vybereme proměnnou country a všechny numerické proměnné, k čemuž poslouží funkce select(). Poté bude následovat funkce pivot_longer(). Tato funkce má jeden povinný argument, a to cols, pomocí kterého specifikujeme, které proměnné chceme převést do širokého formátu. Není nutné vybrat všechny existující proměnné, naopak pro naše potřeby je lepší nechat proměnnou countries v původní podobě. Kromě cols, jsou dalšími dvěma užitečnými argumenty names_to a values_to, pomocí kterých lze specifikovat názvy nově vytvořených sloupců. První z argumentů určí název sloupce obsahují názvy původních proměnných, druhý poté název sloupce, ve kterém budou uchovány naměřené hodnoty.\n\ncountries %>% \n  select(country, where(is.numeric)) %>% \n  pivot_longer(cols = -country,\n               names_to = \"variable\",\n               values_to = \"max_value\")\n\n# A tibble: 342 × 3\n   country  variable        max_value\n   <chr>    <chr>               <dbl>\n 1 Belgium  gdp            450506.   \n 2 Belgium  population   11398589    \n 3 Belgium  area            30528    \n 4 Belgium  life_exp           81.2  \n 5 Belgium  uni_prc             0.36 \n 6 Belgium  poverty_risk        0.203\n 7 Belgium  material_dep        0.113\n 8 Belgium  hdi                 0.92 \n 9 Belgium  dem_index           7.78 \n10 Bulgaria gdp             55182.   \n# … with 332 more rows\n\n\nTento kód provede výše popsané. Pomocí kombinace funkcí select() a pomocné funkce where() (viz. Sekce 10.2) vybereme proměnné. Funkce pivot_longer() se postará o zbytek. Argumentem cols určime, že převedeny do dlouhého formátu mají být všechny proměnné kromě country a nově vytvořené proměnné se mají jmenovat variable a max_value. Výsledkem je dataframe s menším počtem sloupců, zato výrazně větším počtem řádků. Každý řádek reprezentuje hodnotu jedné proměnné v jedné zemi.\nTeď už zbývá jen vybrat pro každou z původních proměnných nejvyšší naměřenou hodnotu. Toho docílíme pomocí nám již známých funkcí group_by() a slice_max(). A to je vše! Z výsledného dataframu lze vyčíst že nejvyššímu pozorovanému Indexu lidského rozvoje (gdp) se těší Norsko, nebo že nejvyšší podíl lidí ohrožených chudobou je 41,6 % a trpí jím Severní Makedonie.\n\ncountries %>% \n  select(country, where(is.numeric)) %>% \n  pivot_longer(cols = -country,\n               names_to = \"variable\",\n               values_to = \"max_value\") %>% \n  group_by(variable) %>% \n  slice_max(max_value)\n\n# A tibble: 9 × 3\n# Groups:   variable [9]\n  country         variable        max_value\n  <chr>           <chr>               <dbl>\n1 Turkey          area           783562    \n2 Norway          dem_index           9.87 \n3 Germany         gdp           3386000    \n4 Norway          hdi                 0.95 \n5 Switzerland     life_exp           83.3  \n6 North Macedonia material_dep        0.481\n7 Germany         population   82792351    \n8 North Macedonia poverty_risk        0.416\n9 Ireland         uni_prc             0.405"
  },
  {
    "objectID": "siroky-dlouhy-format.html#z-dlouhého-do-širokého-formátu",
    "href": "siroky-dlouhy-format.html#z-dlouhého-do-širokého-formátu",
    "title": "12  Široký a dlouhý formát",
    "section": "12.2 Z dlouhého do širokého formátu",
    "text": "12.2 Z dlouhého do širokého formátu\nJak již asi tušíte, opakem pivot_longer() je funkce pivot_wider(), pomocí které je možné řádky “roztáhnout” do sloupců. Tato funkce má dva povinné argumenty, a to names_from a values_from. První z těchto argumentů převede hodnoty ve vybraném sloupci na názvy nových sloupců. Druhý argument poté nové sloupce zaplní hodnotami ze zvolené proměnné.\nPoněkud umělým, ale názorným příkladem může být, pokud by naším cílem bylo vytvořit dataframe obsahující minimální hodnotu ohrožení chudobou podle převažujícího náboženského vyznání. Tento dataframů by měl být dobře srozumitelný pro naše čtenáře, a měl by proto mít podobu kontingenční tabulky.\nZačneme podobně, jako v předchozím cvičení. Nejdříve vybereme všechny relevantní proměnné, tedy převažující náboženské vyznání (maj_belief), členství v Evropské unii (eu_member) a HDP (gdp). Poté kombinací funkcí group_by() a slice_min() získáme nejnižší pozorované hodnoty ohrožení chudobou pro každou kombinaci převažujícího vyznání a členství v EU. Nakonec už zbývá pouze využít funkce pivot_wider() pro převedení proměnné maj_belief() do sloupců a zaplnění nově vzniklých sloupců pomocí hodnot z poverty_risk. A máme hotovo\n\ncountries %>% \n  select(maj_belief, eu_member, poverty_risk) %>% \n  group_by(maj_belief, eu_member) %>%\n  slice_min(poverty_risk) %>% \n  pivot_wider(names_from = maj_belief, values_from = poverty_risk)\n\n# A tibble: 2 × 6\n# Groups:   eu_member [2]\n  eu_member catholic  islam nonbelief orthodox protestantism\n  <chr>        <dbl>  <dbl>     <dbl>    <dbl>         <dbl>\n1 no           0.181  0.413    NA        0.367         0.16 \n2 yes          0.163 NA         0.122    0.252         0.157\n\n\nVšimněme si, že některé buňky jsou prázdné, protože naše data neobsahují všechny kombinace náboženského vyznání a členství v Evropské unii."
  },
  {
    "objectID": "spojovani-dat.html#spojovací-funkce",
    "href": "spojovani-dat.html#spojovací-funkce",
    "title": "13  Spojování dataframů",
    "section": "13.1 Spojovací funkce",
    "text": "13.1 Spojovací funkce\nSpojovat dva datasety lze více způsoby, všechny ale vyžadují klíč, tedy proměnou, která je přítomná v obou datframech a pomocí které budou propojeny jednotlivé řádky.\n\n\n\n*_join() funkce\n\n\nFunkcí pro spojení dvou dataframů nabízí Tidyverse více. První z nich, left_join(), připojí k prvnímu specifikovanému dataframu všechny řádky druhého dataframu se shodnou hodnotou klíče. Řádky, které se nachází pouze v druhém dataframu, ale ne v prvním, jsou ztraceny. Analogickou funkcí je poté right_join(), která zachová pouze řádky s hodnotami klíče, nacházejícím se v druhém dataframu. inner_join() je nejpřísnější z funkcí a při spojení dataframů zachová pouze řádky s hodnotami nacházejícími se v obou datasetech. Naopak funkce full_join() je nejliberálnější a zachová při spojení všechna data.\nPro ukázku spojovacích funkcí opustíme dataset countries a místo toho se podíváme do zvířecí říše, konkrétně na data z American Kennel Club. Jedná se o dva dasety, které jsou dostupné v rámci Tidytuesday. Importovat je lze přímo ze repozitáře projektu:\n\nbreed_traits <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-02-01/breed_traits.csv')\nbreed_ranks <- read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2022/2022-02-01/breed_rank.csv')\n\nPrvní z těchto datasetů obsahuje hodnocení o vlastnostech psích plemen jak byly hodnoceny členy klubu. Vlastností tu najdeme celou řadu, od délky kožichu po přátelskost nebo slintavost. Druhý dataset obsahuje informace o popularitě plemen za posledních zhruba 10 let, plus pár popisných odkazů:\n\nnames(breed_traits)\n\n [1] \"Breed\"                      \"Affectionate With Family\"  \n [3] \"Good With Young Children\"   \"Good With Other Dogs\"      \n [5] \"Shedding Level\"             \"Coat Grooming Frequency\"   \n [7] \"Drooling Level\"             \"Coat Type\"                 \n [9] \"Coat Length\"                \"Openness To Strangers\"     \n[11] \"Playfulness Level\"          \"Watchdog/Protective Nature\"\n[13] \"Adaptability Level\"         \"Trainability Level\"        \n[15] \"Energy Level\"               \"Barking Level\"             \n[17] \"Mental Stimulation Needs\"  \n\nnames(breed_ranks)\n\n [1] \"Breed\"     \"2013 Rank\" \"2014 Rank\" \"2015 Rank\" \"2016 Rank\" \"2017 Rank\"\n [7] \"2018 Rank\" \"2019 Rank\" \"2020 Rank\" \"links\"     \"Image\"    \n\n\nVšimněme si, že oba datasety obsahují proměnnou Breed, tedy plemeno psa. To bude naším klíčem, tedy proměnou, pomocí které spojíme oba dataframy dohromady. Důvodem, proč nejsou oba datasety spojené už od začátku, je že ne všechna plemena obsažená v breed_traits se umístila v ročním hodnocení, a chybí tedy v breed_ranks. Při spojování dat je tedy na nás, jak se touto komplikací vypořádáme.\nPrvní možností je vzít dataframe breed_traits a přilepit k němu breed_ranks, pomocí funkce left_join(). Výsledkem bude dataframe, který obsahuje všechny informace z breed_traits a pokud se některé plemeno neumístilo v žebříčku z bree_ranks, bude mít v proměnných hodnocení chybějící hodnotu:\n\nleft_join(breed_traits, breed_ranks, by = \"Breed\")\n\n\n\n# A tibble: 10 × 27\n   Breed Affec…¹ Good …² Good …³ Shedd…⁴ Coat …⁵ Drool…⁶ Coat …⁷ Coat …⁸ Openn…⁹\n   <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <chr>   <chr>     <dbl>\n 1 Retr…       5       5       5       4       2       2 Double  Short         5\n 2 Fren…       5       5       4       3       1       3 Smooth  Short         5\n 3 Germ…       5       5       3       4       2       2 Double  Medium        3\n 4 Retr…       5       5       5       4       2       2 Double  Medium        5\n 5 Bull…       4       3       3       3       3       3 Smooth  Short         4\n 6 Pood…       5       5       3       1       4       1 Curly   Long          5\n 7 Beag…       3       5       5       3       2       1 Smooth  Short         3\n 8 Rott…       5       3       3       3       1       3 Smooth  Short         3\n 9 Poin…       5       5       4       3       2       2 Smooth  Short         4\n10 Dach…       5       3       4       2       2       2 Smooth  Short         4\n# … with 17 more variables: `Playfulness Level` <dbl>,\n#   `Watchdog/Protective Nature` <dbl>, `Adaptability Level` <dbl>,\n#   `Trainability Level` <dbl>, `Energy Level` <dbl>, `Barking Level` <dbl>,\n#   `Mental Stimulation Needs` <dbl>, `2013 Rank` <dbl>, `2014 Rank` <dbl>,\n#   `2015 Rank` <dbl>, `2016 Rank` <dbl>, `2017 Rank` <dbl>, `2018 Rank` <dbl>,\n#   `2019 Rank` <dbl>, `2020 Rank` <dbl>, links <chr>, Image <chr>, and\n#   abbreviated variable names ¹​`Affectionate With Family`, …\n\n\nVšimněme si, že například němečtí ovčáci nebyli hodnoceni a u proměnných 2013 Rank až 2019 Rank tedy mají chybějící hodnotu. Naopak pro buldoky jsou k dispozici k dispozici všechna data.\nAlternativou k left_join() je funkce right_join(). Ta provede velmi podobnou operaci, jako jsme viděli výše, výchozím dataframem zde ale bude breed_ranks.\n\nright_join(breed_traits, breed_ranks, by = \"Breed\")\n\n\n\n# A tibble: 10 × 27\n   Breed Affec…¹ Good …² Good …³ Shedd…⁴ Coat …⁵ Drool…⁶ Coat …⁷ Coat …⁸ Openn…⁹\n   <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <chr>   <chr>     <dbl>\n 1 Bull…       4       3       3       3       3       3 Smooth  Short         4\n 2 Pood…       5       5       3       1       4       1 Curly   Long          5\n 3 Beag…       3       5       5       3       2       1 Smooth  Short         3\n 4 Rott…       5       3       3       3       1       3 Smooth  Short         3\n 5 Dach…       5       3       4       2       2       2 Smooth  Short         4\n 6 Boxe…       4       5       3       2       2       3 Smooth  Short         4\n 7 Pome…       5       3       3       2       3       1 Double  Long          3\n 8 Hava…       5       5       5       2       3       1 Double  Long          5\n 9 Brit…       3       4       4       3       3       1 Double  Short         3\n10 Pugs        5       5       4       4       2       1 Smooth  Short         5\n# … with 17 more variables: `Playfulness Level` <dbl>,\n#   `Watchdog/Protective Nature` <dbl>, `Adaptability Level` <dbl>,\n#   `Trainability Level` <dbl>, `Energy Level` <dbl>, `Barking Level` <dbl>,\n#   `Mental Stimulation Needs` <dbl>, `2013 Rank` <dbl>, `2014 Rank` <dbl>,\n#   `2015 Rank` <dbl>, `2016 Rank` <dbl>, `2017 Rank` <dbl>, `2018 Rank` <dbl>,\n#   `2019 Rank` <dbl>, `2020 Rank` <dbl>, links <chr>, Image <chr>, and\n#   abbreviated variable names ¹​`Affectionate With Family`, …\n\n\nV tomto případě již plemena jako zlatý retrívr nebo německý ovčák ve výsledném dataframu nenajdeme vůbec, protože nejsou obsažena v dataframu breed_ranks.\n\n\n\n\n\n\nJak napravo, tak nalevo\n\n\n\nVýsledek funkce left_join(breed_traits, breed_ranks) je ekvivalentní funkci right_join(breed_ranks, breed_traits).\n\n\nPro zachování pouze plemen, která jsou obsažena v obou dataframech, lze aplikovat funkci inner_join(). Výsledný dataframe bude mít mnohem méně řádků, než ty předchozí, pouze 49, protože většina plemen není v dataframu breed_ranks:\n\ninner_join(breed_traits, breed_ranks, by = \"Breed\")\n\nPoslední verzí je permisivní outer_joint(), která spojí oba dataframy a zachová přitom všechny řádky:\n\nfull_join(breed_traits, breed_ranks, by = \"Breed\")"
  },
  {
    "objectID": "spojovani-dat.html#kterou-spojovací-funkci-použít",
    "href": "spojovani-dat.html#kterou-spojovací-funkci-použít",
    "title": "13  Spojování dataframů",
    "section": "13.2 Kterou spojovací funkci použít?",
    "text": "13.2 Kterou spojovací funkci použít?\nKaždá z výše zmíněných funkcí se hodí pro jinou situaci. Která je ta pravá? Pokud je hlavním cílem naší práce analýza charakteristik jednotlivých plemen, bude pro nás nejužitečnější left_join(breed_traits, breed_ranks). Na druhou stranu, pokud by pro naši analýzu bylo stěžejní roční hodnocení, uplatili bychom spíše right_join(breed_traits, breed_ranks), protože plemena, který nebyla hodnocena, pro nás nejsou zajímavá. Pro analýzu vztahů mezi charakteristikami a hodnocením pro nás budou užitečná pouze plemena, pro která máme k dispozici všechny informace, a ty bychom získali pomocí inner_join(breed_traits, breed_ranks). Nakonec, pokud by naším cílem bylo jen datasety spojit, aniž bychom přišli o jakkýkoliv data, například pro jejich uskladnění, využili bychom full_join(breed_traits, breed_ranks)."
  },
  {
    "objectID": "transformace-promennych.html#jednoduché-transformace",
    "href": "transformace-promennych.html#jednoduché-transformace",
    "title": "14  Transformace proměnných",
    "section": "14.1 Jednoduché transformace",
    "text": "14.1 Jednoduché transformace\nFunkce mutate() přijímá jako svůj první argument dataframe, dalšími argumenty jsou poté jednotlivé transformace:\n\ncountries %>% \n  mutate(gdp_milliards = gdp / 1000,\n         poverty_risk  = poverty_risk * 100) %>% \n  select(country, gdp, gdp_milliards, poverty_risk)\n\n# A tibble: 38 × 4\n   country       gdp gdp_milliards poverty_risk\n   <chr>       <dbl>         <dbl>        <dbl>\n 1 Belgium   450506.         451.          20.3\n 2 Bulgaria   55182.          55.2         38.9\n 3 Czechia   207772.         208.          12.2\n 4 Denmark   298276.         298.          17.2\n 5 Germany  3386000         3386           19  \n 6 Estonia    25657.          25.7         23.4\n 7 Ireland   324038.         324.          22.7\n 8 Greece    184714.         185.          34.8\n 9 Spain    1208248         1208.          26.6\n10 France   2353090         2353.          17.1\n# … with 28 more rows\n\n\nZde je vidět nejen aplikace funkce mutate(), ale i její hlavní primární výhoda. Protože jejím výsledkem je dataframe s provedenými transformacemi, je možné na ní navázat dalšími funkcemi, jako je select() nebo filter(). Novým proměnným také můžeme jednoduše přiřadit jméno (viz Kapitola 5). Pokud uložíme výsledek transformace pod novým jménem, bude vytvořena nová proměnná (v našem případě gdp_milliards). Pokud použijeme jméno již existující proměnné, bude přepsána hodnotami (poverty_risk).\nJednou z analýz, která se v datasetu nabízí, je srovnání ekonomické produktivity zemí, a jednou z nejpopulárnějších metrik ekonomické produktivity je HDP. Čtenáři se znalostmi ekonomie ale již jistě tuší problém. HDP se silně odvíjí od počtu obyvatel a není tedy úplně smysluplné porovnávat obří Německo s maličkým Českem. Pro serióznější analýzu by proto bylo lepší využít standardizovanější míru, jakou je například HDP na hlavu. Tuto proměnnou náš dataset neobsahuje, nemusíme ale smutnit. Máme k dispozici jak HDP, tak počet obyvatel a od kýženého výsledku nás děli jedna matematická operace.\nPro rychlé srovnání zemí by také bylo vhodné převést data do standardizovaných jednotek. Takovou jednotkou jsou mimo jiné z skóry, získatelné odečtením průměru proměnné od každé naměřené hodnoty a vydělením rozdílu směrodatnou odchylkou, tedy \\(z_i = \\frac{x_i - \\bar{x}}{sd(x)}\\) . Protože se jedná o populární formu standardizace, R pro ni nabízí funkci scale():\n\ncountries %>% \n  mutate(gdp_pc = gdp / population,\n         gdp_pc_scaled = scale(gdp_pc)) %>% \n  select(country, gdp_pc, gdp_pc_scaled)\n\n# A tibble: 38 × 3\n   country   gdp_pc gdp_pc_scaled[,1]\n   <chr>      <dbl>             <dbl>\n 1 Belgium  0.0395              0.357\n 2 Bulgaria 0.00783            -1.06 \n 3 Czechia  0.0196             -0.534\n 4 Denmark  0.0516              0.897\n 5 Germany  0.0409              0.419\n 6 Estonia  0.0194             -0.540\n 7 Ireland  0.0671              1.59 \n 8 Greece   0.0172             -0.640\n 9 Spain    0.0259             -0.252\n10 France   0.0352              0.162\n# … with 28 more rows\n\n\nZ transformované proměnné gdp_pc_scaled je vidět, že z skór České republiky je -0.53, naše HDP na hlavu se tedy nachází zhruba půl směrodatné odchylky pod průměrem. Naopak Irsko se těší HDP na hlavu o 1.5 směrodatné odchylky vyšší, než je průměr všech zemí v datasetu."
  },
  {
    "objectID": "transformace-promennych.html#transformace-po-skupinách",
    "href": "transformace-promennych.html#transformace-po-skupinách",
    "title": "14  Transformace proměnných",
    "section": "14.2 Transformace po skupinách",
    "text": "14.2 Transformace po skupinách\nVe výše zmíněných příkladech byly transformace aplikovány na vybrané proměnné jako celek. Co když ale není naším cílem transformovat všechny hodnoty stejným způsobem?\nPro detailnější analýzu ekonomické produktivity zemí může být zajímavé zohlednit jejich politickou historii. Jak si například Česká republika vede ve srovnání s ostatními postsovětskými zeměmi? Pro zodpovězení této otázky je nutné aplikovat funkcí scale() na každou skupinu proměnné postsoviet zvlášť. Naštěstí pro nás, tato operace nemůže být jednoduší, a to díky funkci group_by(), se kterou jsme se již setkali při řezání dataframů (Sekce 11.3):\n\ncountries %>% \n  group_by(postsoviet) %>% \n  mutate(gdp_pc = gdp / population,\n         gdp_pc_scaled = scale(gdp_pc)) %>% \n  ungroup() %>% \n  select(country, postsoviet, gdp_pc, gdp_pc_scaled)\n\n# A tibble: 38 × 4\n   country  postsoviet  gdp_pc gdp_pc_scaled[,1]\n   <chr>    <chr>        <dbl>             <dbl>\n 1 Belgium  no         0.0395             -0.245\n 2 Bulgaria yes        0.00783            -0.781\n 3 Czechia  yes        0.0196              0.522\n 4 Denmark  no         0.0516              0.329\n 5 Germany  yes        0.0409              2.89 \n 6 Estonia  yes        0.0194              0.507\n 7 Ireland  no         0.0671              1.07 \n 8 Greece   no         0.0172             -1.31 \n 9 Spain    no         0.0259             -0.894\n10 France   no         0.0352             -0.453\n# … with 28 more rows\n\n\nPřestože tento dataframe na první pohled vypadá velmi podobně jako ten předchozí, hodnoty proměnné gdp_pc_scaled jsou odlišné. Česká republika má nyní hodnotu 0.52. Nachází se tedy zhruba půl směrodatné odchylky nad průměrem ostatních postsovětských zemí. Naopak z skór Irska se snížil na 1.1, protože ve srovnání s ostatními západními zeměmi je jeho HDP na hlavu pouze jednu směrodatnou odchylku nad průměrem.\nTohoto srovnání jsme dosáhli právě tím, že jsme před aplikací funkce mutate() rozdělili dataframe pomocí group_by() a všechny následující operace tedy budou prováděny pro západní a postsovětské funkce zvlášť.\n\n\n\n\n\n\nPo použití vypněte\n\n\n\nJakmile jednou aplikujete funkci group_by(), bude aktivní ve všech následujících krocích. To může vést ke zmatkům, zpravidla proto, že na ni zapomenete a aplikujete funkce na každou skupinu zvlášť, aniž byste si to uvědomovali. Proto pokaždé, když skončíte s transformací dat nezapomeňte seskupování ukončit pomocí ungroup()."
  },
  {
    "objectID": "transformace-promennych.html#řádkové-operace",
    "href": "transformace-promennych.html#řádkové-operace",
    "title": "14  Transformace proměnných",
    "section": "14.3 Řádkové operace",
    "text": "14.3 Řádkové operace\nPřesuňme se teď od ekonomické produktivitě k palčivějším tématům. Jedním z ekonomicko-sociálních problémů, se kterými se musí každá země vypořádat, jsou obyvatelé ohrožení chudobou (proměnná poverty_risk) a obyvatelé v materiální deprivaci (material_dep). Naneštěstí pro nás nemáme k dispozici podíl obyvatel ohrožených alespoň jedním z těchto rizik, můžeme ale získat alespoň konzervativní odhad. Maximální možný podíl lidí ohrožených chudobou nebo v materiální deprivaci je možné získat jednoduše součtem obou hodnot pro každou zemi.\nTento krapet kostrbatý problém nám poslouží pro demonstraci řádkových (rowwise) transformací. R ve svém výchozím nastavení aplikuje funkce po sloupcích (columnwise). To s sebou přináší poněkud zákeřnou komplikaci při snaze sečíst dvě hodnoty na stejném řádku dataframu. Pokud chceme aplikovat funkci po řádcích, nikoliv po sloupcích, je nutné využít funkce rowwise(). Ta funguje velmi obdobně jako group_by(), a to včetně jejího “vypnutí” pomocí ungroup():\n\ncountries %>% \n  rowwise() %>% \n  mutate(poverty_or_dep = sum(poverty_risk, material_dep, na.rm = TRUE)) %>% \n  ungroup() %>% \n  select(country, poverty_or_dep)\n\n# A tibble: 38 × 2\n   country  poverty_or_dep\n   <chr>             <dbl>\n 1 Belgium           0.316\n 2 Bulgaria          0.827\n 3 Czechia           0.22 \n 4 Denmark           0.24 \n 5 Germany           0.281\n 6 Estonia           0.35 \n 7 Ireland           0.375\n 8 Greece            0.708\n 9 Spain             0.394\n10 France            0.282\n# … with 28 more rows\n\n\nPomocí funkce rowwise() jsme získali součet podílu lidí ohrožených chudobou a lidí v materiální deprivaci pro každou ze zemí. Jak je vidět, alespoň do jedné z těchto kategorií v České republice spadá maximální 22 % obyvatel."
  },
  {
    "objectID": "transformace-promennych.html#podmíněné-transformace",
    "href": "transformace-promennych.html#podmíněné-transformace",
    "title": "14  Transformace proměnných",
    "section": "14.4 Podmíněné transformace",
    "text": "14.4 Podmíněné transformace\nJednou z myšlenkových operací, ve které počítače vynikají, je rigidní “pokud je splněna podmínka, udělej X”. Pojďme toho využít.\nV předchozí sekci jsme porovnávali země na základě standardizovaného HDP na hlavu. Co kdybychom tuto analýzy chtěli vzít o krok dále a vytvořit novou kategoriální proměnnou, jejíž hodnota bude Above average pro země s nadprůměrným HDP na hlavu, a Below average pro země podprůměrné.\nK tomu nám dobře poslouží funkce if_else(), která má tři povinné argumenty. Tím prvním je podmínka, jejímž výsledkem musí být buď hodnota “pravda” (TRUE) nebo “nepravda” (FALSE). Druhým argumentem je operace, která bude provedena, pokud je zmíněná podmínka splněna, třetím argumentem poté nepřekvapivě operace provedené v případě nesplnění podmínky. Aplikace pro náš konkrétní případ by vypadala následovně:\n\ncountries %>% \n  mutate(gdp_pc_scaled = scale(gdp / population),\n         gdp_pc_cat = if_else(gdp_pc_scaled > 0,\n                              true = \"Above average\",\n                              false = \"Below average\")) %>% \n  select(country, gdp_pc_scaled, gdp_pc_cat)\n\n# A tibble: 38 × 3\n   country  gdp_pc_scaled[,1] gdp_pc_cat   \n   <chr>                <dbl> <chr>        \n 1 Belgium              0.357 Above average\n 2 Bulgaria            -1.06  Below average\n 3 Czechia             -0.534 Below average\n 4 Denmark              0.897 Above average\n 5 Germany              0.419 Above average\n 6 Estonia             -0.540 Below average\n 7 Ireland              1.59  Above average\n 8 Greece              -0.640 Below average\n 9 Spain               -0.252 Below average\n10 France               0.162 Above average\n# … with 28 more rows\n\n\nCo kdybychom ale chtěli, aby výsledkem operace byly více než dvě hodnoty? Možná nám přijde, že klasifikovat země pouze jako nadprůměrné a podprůměrné je příliš redukcionistické (populární to výčitka mezi sociology). Země bychom místo toho raději rozdělili do čtyř kategorií:\n\nbelow average pro země se z skóre nižším než -1\nslightly below average pro země v intervalu -1 až 0\nslightly above average analogicky pro země mezi 0 a 1\nabove average pro ty se z skórem vyšším, než 1.\n\nJednou z možností je využít řadu na sebe navazujících if_else funkcí. Tento postup by technicky fungoval, povede ale k mnoha slzám a frustracím přímo úměrným množství funkcí, které je třeba správně zřetězit. Elegantnějším řešením je využít funkci case_when(), která byla vytvořena právě pro tento případ:\n\ncountries %>% \n  mutate(gdp_pc = scale(gdp / population),\n         gdp_pc_cat = case_when(gdp_pc < -1 ~ \"Below average\",\n                                gdp_pc <= 0 ~ \"Slightly below average\",\n                                gdp_pc <= 1 ~ \"Slightly above average\",\n                                gdp_pc  > 1 ~ \"Above average\",\n                                TRUE ~ \"Unknown\")) %>% \n  select(country, gdp_pc, gdp_pc_cat)\n\n# A tibble: 38 × 3\n   country  gdp_pc[,1] gdp_pc_cat            \n   <chr>         <dbl> <chr>                 \n 1 Belgium       0.357 Slightly above average\n 2 Bulgaria     -1.06  Below average         \n 3 Czechia      -0.534 Slightly below average\n 4 Denmark       0.897 Slightly above average\n 5 Germany       0.419 Slightly above average\n 6 Estonia      -0.540 Slightly below average\n 7 Ireland       1.59  Above average         \n 8 Greece       -0.640 Slightly below average\n 9 Spain        -0.252 Slightly below average\n10 France        0.162 Slightly above average\n# … with 28 more rows\n\n\nFunkce case_when() má oproti dosavadním funkcí atypickou syntax. Každá z logických podmínek je kondezovaná do formule podminka ~ vysledek. První řádek v této funkci, gdp_pc < -1 ~ \"Below average\", tedy říká “pokud je hodnota proměnné gdp_pc menší než -1, vrať hodnotu Below average”. Pokud tato podmínka splněná není, funkce zkontroluje podmínku následující. Podmínky jsou ověřovány jedna po druhé, přičemž podmínky na vyšších místech jsou ověřeny dříve. Speciální podmínkou je TRUE ~ vysledek, která je je vždy splněna. To se hodí pokud jsou v datech přítomny hodnoty, které nesplňují žádnou z předchozích podmínek. Kdy se může stát, že hodnota nesplňuje žádnou z našich podmínek? Například, pokud se jedná o hodnotu chybějící:\n\ncountries %>% \n  mutate(gdp_pc = scale(gdp / population),\n         gdp_pc_cat = case_when(gdp_pc < -1 ~ \"Below average\",\n                                gdp_pc <= 0 ~ \"Slightly below average\",\n                                gdp_pc <= 1 ~ \"Slightly above average\",\n                                gdp_pc  > 1 ~ \"Above average\",\n                                TRUE ~ \"Unknown\")) %>% \n  select(country, gdp_pc, gdp_pc_cat) %>% \n  filter(is.na(gdp_pc))\n\n# A tibble: 4 × 3\n  country                gdp_pc[,1] gdp_pc_cat\n  <chr>                       <dbl> <chr>     \n1 Liechtenstein                  NA Unknown   \n2 Montenegro                     NA Unknown   \n3 Turkey                         NA Unknown   \n4 Bosnia and Herzegovina         NA Unknown"
  },
  {
    "objectID": "sumarizace-promennych.html#jednoduchá-sumarizace",
    "href": "sumarizace-promennych.html#jednoduchá-sumarizace",
    "title": "15  Sumarizace proměnných",
    "section": "15.1 Jednoduchá sumarizace",
    "text": "15.1 Jednoduchá sumarizace\nJak již bylo zmíněno, základní aplikace summarise() je velmi podobná transformaci proměnných. Výpočet průměru a směrodatné odchylky průměrné naděje na dožití je tedy jednodochý. V rámci summarise() je možné aplikovat nejen klasické funkce jako jsou mean() nebo sd(), ale i základní matematické operace. Stejně tak je možné i používat i funkce vnořené. Toho využijme pro výpočet průměrné absolutní odchylky (mean absolute deviation), alternativy ke směrodatné odchylce:\n\ncountries %>% \n  summarise(mean = mean(life_exp, na.rm = TRUE),\n            sd   = sd(life_exp, na.rm = TRUE),\n            mae  = mean(abs(life_exp - mean(life_exp, na.rm = TRUE)), na.rm = TRUE))\n\n# A tibble: 1 × 3\n   mean    sd   mae\n  <dbl> <dbl> <dbl>\n1  79.6  2.82  2.58\n\n\nPrůměrná naděje na dožití v našem datasetu je 79.6 let, se směrodatnou odchylkou 2.8 roku a průměrnou absolutní odchylkou 2.6 roku. Protože naději na dožití některých zemí neznáme, je nutné využít na.rm = TRUE pro odstranění chybějících hodnot (viz Sekce 6.2)."
  },
  {
    "objectID": "sumarizace-promennych.html#sumarizace-po-skupinách",
    "href": "sumarizace-promennych.html#sumarizace-po-skupinách",
    "title": "15  Sumarizace proměnných",
    "section": "15.2 Sumarizace po skupinách",
    "text": "15.2 Sumarizace po skupinách\nFunkci summarise() lze jako mnoho již představených kombinovat s funkcí group_by() pro skupinovou analýzu. Pro získání průměru, směrodatné odchylky a průměrné absolutní odchylky naděje na dožití postsovětských a západních zemí:\n\ncountries %>% \n  group_by(postsoviet) %>% \n  summarise(mean = mean(life_exp, na.rm = TRUE),\n            sd   = sd(life_exp, na.rm = TRUE),\n            mae  = mean(abs(life_exp - mean(life_exp, na.rm = TRUE)), na.rm = TRUE))\n\n# A tibble: 2 × 4\n  postsoviet  mean    sd   mae\n  <chr>      <dbl> <dbl> <dbl>\n1 no          81.4  1.76  1.06\n2 yes         77.1  1.97  1.57\n\n\nPostsovětské země mají v průměru nižší naději na dožití, než ty západní, jsou ale také mezi nimi větší rozdíly, což je možné vidět jak na základě směrodatné, tak absolutní odchylky."
  },
  {
    "objectID": "mnoho-promennych.html#sec-across-mutate",
    "href": "mnoho-promennych.html#sec-across-mutate",
    "title": "16  Transformace a sumarizace více proměnných",
    "section": "16.1 Transformace většího množství proměnných",
    "text": "16.1 Transformace většího množství proměnných\nDataset countries obsahuje několik kategoriálních proměnných, mezi nimi postsoviet, eu_member, maj_belief a di_cat. Všechny tyto proměnné jsou typu character, pro analýzu by ovšem bylo lepší je převést na typ factor (pro typy objektů viz Kapitola 4).\nJednou možností je aplikovat funkci as.factor() na každou proměnnou zvlášť:\n\ncountries %>% \n  mutate(postsoviet = as.factor(postsoviet),\n         eu_member  = as.factor(eu_member),\n         maj_belief = as.factor(maj_belief),\n         di_cat     = as.factor(di_cat)) %>% \n  select(postsoviet, eu_member, maj_belief, di_cat) %>% \n  head(5)\n\n# A tibble: 5 × 4\n  postsoviet eu_member maj_belief    di_cat          \n  <fct>      <fct>     <fct>         <fct>           \n1 no         yes       catholic      Flawed democracy\n2 yes        yes       orthodox      Flawed democracy\n3 yes        yes       nonbelief     Flawed democracy\n4 no         yes       protestantism Full democracy  \n5 yes        yes       catholic      Full democracy  \n\n\nTímto kódem dosáhneme našeho cíle, nejedná se však o nejelegantnější řešení, jelikož opakovaně aplikujeme stejnou funkci na každou z proměnných zvlášť. To nejen náš kód prodlužuje, ale zároveň zvyšuje šanci, že na některém řádku uděláme chybu. Alternativou je funkce across():\n\ncountries %>% \n  mutate(across(.cols = c(postsoviet, eu_member, maj_belief, di_cat),\n                .fns  = as.factor)) %>% \n  select(postsoviet, eu_member, maj_belief, di_cat) %>% \n  head(5)\n\n# A tibble: 5 × 4\n  postsoviet eu_member maj_belief    di_cat          \n  <fct>      <fct>     <fct>         <fct>           \n1 no         yes       catholic      Flawed democracy\n2 yes        yes       orthodox      Flawed democracy\n3 yes        yes       nonbelief     Flawed democracy\n4 no         yes       protestantism Full democracy  \n5 yes        yes       catholic      Full democracy  \n\n\nFunkce across() má dva nezbytné argumenty. Prvním z nich je .col, pomocí kterého specifikujeme proměnné, na které chceme naši funkci aplikovat. Argument .fns poté specifikuje funkci samotnou. Výsledek je stejný jako v předchozím případě, náš kód je ale kompaktnější.\nTímto ovšem výhody funkce across() nekončí. Proměnné je v ní možné specifikovat nejen tím, že je vyjmenuje jednu po druhé, ale i pomocí pomocných funkcí, se kterými jsme se již setkali v kapitole věnované výběrů sloupců (Sekce 10.2).\nPokud bychom například chtěli zaokrouhlit všechny numerické proměnné v datasetu na dvě desetinná místa, není nutné jejich názvy vypisovat ručně. Stačí využít kombinace funkcí where() a is.numeric():\n\ncountries %>% \n  mutate(across(.cols = where(is.numeric),\n                .fns  = round, 2)) %>% \n  select(where(is.numeric)) %>% \n  head(5)\n\n# A tibble: 5 × 9\n       gdp population   area life_exp uni_prc poverty_risk mater…¹   hdi dem_i…²\n     <dbl>      <dbl>  <dbl>    <dbl>   <dbl>        <dbl>   <dbl> <dbl>   <dbl>\n1  450506.   11398589  30528     81.2    0.36         0.2     0.11  0.92    7.78\n2   55182.    7050034 110879     74.8    0.25         0.39    0.44  0.81    7.03\n3  207772.   10610055  78867     79.2    0.22         0.12    0.1   0.89    7.69\n4  298276.    5781190  43094     81.2    0.33         0.17    0.07  0.93    9.22\n5 3386000    82792351 357022     81      0.25         0.19    0.09  0.94    8.68\n# … with abbreviated variable names ¹​material_dep, ²​dem_index\n\n\nV rámci across() je také možné specifikovat argumenty pro aplikovanou funkci. Výše jsem určili, že numerické proměnné mají být zaoukrouhlené na dvě desetinná místa pomocí .fns = round, 2, kde 2 je argument funkce round(). Alternativně bychom mohli využít takzvanou tilda notaci (tilde notation):\n\ncountries %>% \n  mutate(across(.cols = where(is.numeric),\n                .fns  = ~round(., 2))) %>% \n  select(where(is.numeric)) %>% \n  head(5)\n\n# A tibble: 5 × 9\n       gdp population   area life_exp uni_prc poverty_risk mater…¹   hdi dem_i…²\n     <dbl>      <dbl>  <dbl>    <dbl>   <dbl>        <dbl>   <dbl> <dbl>   <dbl>\n1  450506.   11398589  30528     81.2    0.36         0.2     0.11  0.92    7.78\n2   55182.    7050034 110879     74.8    0.25         0.39    0.44  0.81    7.03\n3  207772.   10610055  78867     79.2    0.22         0.12    0.1   0.89    7.69\n4  298276.    5781190  43094     81.2    0.33         0.17    0.07  0.93    9.22\n5 3386000    82792351 357022     81      0.25         0.19    0.09  0.94    8.68\n# … with abbreviated variable names ¹​material_dep, ²​dem_index\n\n\nNa rozdíl od předchozího příkladu, funkci round() zde předchazí tilda (~) a prvním argumentem je .. Tato tečka (.) slouží jako placeholder pro proměnné dosazované do funkce round(). Jinak řečeno, funkce across() postupně dosadí každou proměnnou specifikovanou pomocí argumentu .cols na místo placeholderu .. Tilda notace je o něco komplexnější, než předchozí způsob, je ale o mnoho flexibilnější, protože nám umožňuje kontrolovat, do kterého argumentu budou námi proměnné dosazeny."
  },
  {
    "objectID": "mnoho-promennych.html#sumarizace-většího-množsví-proměnných",
    "href": "mnoho-promennych.html#sumarizace-většího-množsví-proměnných",
    "title": "16  Transformace a sumarizace více proměnných",
    "section": "16.2 Sumarizace většího množsví proměnných",
    "text": "16.2 Sumarizace většího množsví proměnných\nFunkci across() je možné aplikovat v rámci summarise() identicky jako v případě mutate(). Toho využijeme primárně pro výpočet deskriptivních statistik. Stejně jako v předchozích kapitál, i zde můžeme můžeme funkce navazovat na sebe:\n\ncountries %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = mean, na.rm = TRUE)) %>% \n  mutate(across(.cols = everything(),\n                .fns = round, 2))\n\n# A tibble: 1 × 9\n      gdp population    area life_exp uni_prc poverty_risk mater…¹   hdi dem_i…²\n    <dbl>      <dbl>   <dbl>    <dbl>   <dbl>        <dbl>   <dbl> <dbl>   <dbl>\n1 484601.   16754743 156019.     79.6    0.29         0.24    0.18  0.87    7.64\n# … with abbreviated variable names ¹​material_dep, ²​dem_index\n\n\nVšimněme si, že při výpočtu průměru numerických proměnných bylo nutné odstranit chybějící proměnné pomocí na.rm = TRUE (s tímto argumentem jsme se již setkali, viz Sekce 6.2). Všechny získané průměry jsme poté zaokrouhlili pomocí mutate().\nVýsledkem jsou data v širokém formátu (Kapitola 12). Pro čitelnost bude lepší je převést do formátu dlouhého:\n\ncountries %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = mean, na.rm = TRUE)) %>% \n  mutate(across(.cols = everything(),\n                .fns = round, 2)) %>% \n  pivot_longer(cols = everything(),\n               names_to = \"variable\",\n               values_to = \"mean\")  \n\n# A tibble: 9 × 2\n  variable            mean\n  <chr>              <dbl>\n1 gdp            484601.  \n2 population   16754743   \n3 area           156019.  \n4 life_exp           79.6 \n5 uni_prc             0.29\n6 poverty_risk        0.24\n7 material_dep        0.18\n8 hdi                 0.87\n9 dem_index           7.64"
  },
  {
    "objectID": "mnoho-promennych.html#analýza-po-skupinách",
    "href": "mnoho-promennych.html#analýza-po-skupinách",
    "title": "16  Transformace a sumarizace více proměnných",
    "section": "16.3 Analýza po skupinách",
    "text": "16.3 Analýza po skupinách\nStejně v předchozích kapitolách, i zde můžeme aplikovat funkci group_by() pro skupinovou sumarizaci (a transformaci) dat:\n\ncountries %>% \n  group_by(eu_member) %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = mean, na.rm = TRUE)) %>% \n  mutate(across(.cols = -eu_member,\n                .fns = round, 2))\n\n# A tibble: 2 × 10\n  eu_member     gdp popul…¹   area life_…² uni_prc pover…³ mater…⁴   hdi dem_i…⁵\n  <chr>       <dbl>   <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <dbl>   <dbl>\n1 no        152949.  1.19e7 1.45e5    78.6    0.27    0.31    0.26  0.84    6.87\n2 yes       567514.  1.83e7 1.60e5    79.9    0.3     0.23    0.17  0.88    7.89\n# … with abbreviated variable names ¹​population, ²​life_exp, ³​poverty_risk,\n#   ⁴​material_dep, ⁵​dem_index\n\n\nVýsledkem je dataframe, který sumarizuje numerické proměnné pro západní a postsovětské země zvlášť. Všimněme si, že při zaokrouhlování je nutné funkci round() aplikovat na všechny proměnné s vyjímkou proměnné eu_member.\nStejně jako v předchozí sekci, i zde je pro čitelnost lepší převést data do dlouhého formátu. Výsledkem bude dataset vhodný pro vizualizaci nebo statistické modelování:\n\ncountries %>% \n  group_by(eu_member) %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = mean, na.rm = TRUE)) %>% \n  mutate(across(.cols = -eu_member,\n                .fns = round, 2)) %>% \n  pivot_longer(cols = -eu_member,\n               names_to = \"variable\",\n               values_to = \"mean\")\n\n# A tibble: 18 × 3\n   eu_member variable            mean\n   <chr>     <chr>              <dbl>\n 1 no        gdp            152949.  \n 2 no        population   11949585.  \n 3 no        area           144874.  \n 4 no        life_exp           78.6 \n 5 no        uni_prc             0.27\n 6 no        poverty_risk        0.31\n 7 no        material_dep        0.26\n 8 no        hdi                 0.84\n 9 no        dem_index           6.87\n10 yes       gdp            567514.  \n11 yes       population   18299258.  \n12 yes       area           159999.  \n13 yes       life_exp           79.9 \n14 yes       uni_prc             0.3 \n15 yes       poverty_risk        0.23\n16 yes       material_dep        0.17\n17 yes       hdi                 0.88\n18 yes       dem_index           7.89\n\n\nNa rozdíl od počítače, lidským čtenářům tento formát zpravdila nepřijde příliš přirozený. Ideálně proto data převedeme zpět do širšího formátu, abychom mohli jednoduše porovnat, která skupina zemí si vede lépe:\n\ncountries %>% \n  group_by(eu_member) %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = mean, na.rm = TRUE)) %>% \n  mutate(across(.cols = -eu_member,\n                .fns = round, 2)) %>% \n  pivot_longer(cols = -eu_member,\n               names_to = \"variable\",\n               values_to = \"mean\") %>% \n  pivot_wider(names_from = eu_member,\n              values_from = mean) %>% \n  mutate(difference = no - yes)\n\n# A tibble: 9 × 4\n  variable              no         yes    difference\n  <chr>              <dbl>       <dbl>         <dbl>\n1 gdp            152949.     567514.    -414565.    \n2 population   11949585.   18299258.   -6349673.    \n3 area           144874.     159999.     -15124.    \n4 life_exp           78.6        79.9        -1.31  \n5 uni_prc             0.27        0.3        -0.0300\n6 poverty_risk        0.31        0.23        0.08  \n7 material_dep        0.26        0.17        0.09  \n8 hdi                 0.84        0.88       -0.0400\n9 dem_index           6.87        7.89       -1.02"
  },
  {
    "objectID": "mnoho-promennych.html#sumarizace-více-proměnných-bez-použití-across",
    "href": "mnoho-promennych.html#sumarizace-více-proměnných-bez-použití-across",
    "title": "16  Transformace a sumarizace více proměnných",
    "section": "16.4 Sumarizace více proměnných bez použití across()",
    "text": "16.4 Sumarizace více proměnných bez použití across()\nPřestože je kombinace funkcí summarise() a across() velmi užitečná, výsledný dataset není vždy ve formátu, se kterým je jednoduché dále pracovat, zvláště pokud aplikujeme více než jednu funkci najednou. Existuje ovšem trik, využívající převedu mezi širokým a dlouhým formátem, kterým si můžeme práci ulehčit.\nNaším cílem může být spočítat průměr, směrodatnou odchylku, maximum a minimum všech numerickách proměnných. Jednou variantou je aplikovat funkci across() a specifikovat více funkcí pomocí lst(). Tato funkce umožňuje aplikovat několik funkcí v rámci jednoho across() Výsledek ovšem není příliš vzhledný:\n\ncountries %>% \n  summarise(across(.cols = where(is.numeric),\n                   .fns  = lst(mean, sd, min, max), na.rm = TRUE))\n\n# A tibble: 1 × 36\n  gdp_m…¹ gdp_sd gdp_min gdp_max popul…² popul…³ popul…⁴ popul…⁵ area_…⁶ area_sd\n    <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n1 484601. 7.94e5  10735. 3386000  1.68e7  2.41e7   38114  8.28e7 156019. 189008.\n# … with 26 more variables: area_min <dbl>, area_max <dbl>,\n#   life_exp_mean <dbl>, life_exp_sd <dbl>, life_exp_min <dbl>,\n#   life_exp_max <dbl>, uni_prc_mean <dbl>, uni_prc_sd <dbl>,\n#   uni_prc_min <dbl>, uni_prc_max <dbl>, poverty_risk_mean <dbl>,\n#   poverty_risk_sd <dbl>, poverty_risk_min <dbl>, poverty_risk_max <dbl>,\n#   material_dep_mean <dbl>, material_dep_sd <dbl>, material_dep_min <dbl>,\n#   material_dep_max <dbl>, hdi_mean <dbl>, hdi_sd <dbl>, hdi_min <dbl>, …\n\n\nVýsledek není nepoužitelný, abychom se ovšem dostali k čitelné tabulce, museli bychom několikrát využít převodu mezi širokým a dlouhým formátem.\nAlternativním způsobem je vybrat proměnné, se kterými chceme pracovat, převést data do dlouhého formátu a poté již aplikovat klasickou funkci summarise(). Nakonec jen výsledky zaokrouhlíme:\n\ncountries %>% \n  select(where(is.numeric)) %>% \n  pivot_longer(everything()) %>% \n  group_by(name) %>% \n  summarise(mean = mean(value, na.rm = TRUE),\n            sd   = sd(value, na.rm = TRUE),\n            min  = min(value, na.rm = TRUE),\n            max  = max(value, na.rm = TRUE)) %>% \n  mutate(across(.cols = where(is.numeric),\n                .fns = round, 2))\n\n# A tibble: 9 × 5\n  name                mean          sd      min         max\n  <chr>              <dbl>       <dbl>    <dbl>       <dbl>\n1 area           156019.     189008.     160      783562   \n2 dem_index           7.64        1.3      4.37        9.87\n3 gdp            484601.     793693.   10735.    3386000   \n4 hdi                 0.87        0.05     0.76        0.95\n5 life_exp           79.6         2.82    74.8        83.3 \n6 material_dep        0.18        0.13     0.04        0.48\n7 population   16754743    24110721.   38114    82792351   \n8 poverty_risk        0.24        0.08     0.12        0.42\n9 uni_prc             0.29        0.08     0.16        0.41\n\n\nHlavní výhodou této metody je, kromě podle našeho názoru větší přehlednosti, že umožňuje specifikovat argumenty pro každou statistickou funkci zvlášť."
  },
  {
    "objectID": "faktory.html#vytváření-faktorů",
    "href": "faktory.html#vytváření-faktorů",
    "title": "17  Práce s faktory",
    "section": "17.1 Vytváření faktorů",
    "text": "17.1 Vytváření faktorů\nNáš dataframe countries obsahuje řadu kategorických proměnných, mezi nimi také maj_belief, tedy převažujícící náboženská skupina v dané zemi. Tato proměnná je uložená jako objekt typu character:\n\nclass(countries$maj_belief)\n\n[1] \"character\"\n\n\nPro převedení této proměnná stačí použe využít funkce as.factor(). Výsledný faktor bude obsahovat úrovně (levels) odpovídající pozorovaným hodnotám původní proměnné. Vzpomeňte si, že faktory nemohou nabývat jiných hodnot, než těch specifikovaných při jejich vzniku:\n\ncountries$maj_belief <- as.factor(countries$maj_belief)\n\nclass(countries$maj_belief)\n\n[1] \"factor\"\n\nlevels(countries$maj_belief)\n\n[1] \"catholic\"      \"islam\"         \"nonbelief\"     \"orthodox\"     \n[5] \"protestantism\"\n\n\nVšimněme si, že pořadí jednotlivých úrovní odpovídá abecedními pořadí. Kromě funkce as.factor() je možné pro vytvoření faktoru využít také Tidyverse funkci as_factor(). Primárním rozdílem mezi nimi je, že funkce as.factors() uspořádá úrovně v abecedním pořadí, zatímco funkce as_factor() v pořadí, v jakém se jednotlivé kategorie objeví v datech. Primární výhodou druhé z funkcí je, že dojde ke stejnému výsledku bez ohledu na jazyk operačního systému."
  },
  {
    "objectID": "faktory.html#pořadí-úrovní",
    "href": "faktory.html#pořadí-úrovní",
    "title": "17  Práce s faktory",
    "section": "17.2 Pořadí úrovní",
    "text": "17.2 Pořadí úrovní\nJednou ze situací, ve kterých je nutné převést kategorické proměnné na faktory, je vizualizace dat. Pokud by nás zajímalo náboženské složení zemí v našem datasetu, můžeme data vizualizovat pomocí funkce qplot() (o které se dozvíme více v příštích kapitolách):\n\nqplot(x = maj_belief, data = countries)\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\nVýsledny graf je funkční, nicméně nepříliš estetický. Kategorie v grafu jsou seřezany podle pořadí úrovní našeho faktoru, vhodnější by ale bylo, aby byly seřazeny sestupně podle frekvence výskytu.\n\n\n\n\n\n\nVarování\n\n\n\nFunkce pro vizualizaci dat převádí kategorické proměnné na faktory automaticky.\n\n\nPokud chceme změnit pořadí kategorií v grafu, nestačí pouze seřadit řádky datasetu, je třeba změnit pořadí úrovní faktoru. Způsobů, jak řadit úrovně je více. Tím základním je specifikovat pořadí úrovní explicitně, pomocí funkce fct_relevel(). Ta přijímá jako první argument faktor, který chceme transformovat a dále jednolivé úrovně v pořadí, v jakém je chceme uložit.\n\ncountries$maj_belief <- fct_relevel(countries$maj_belief,\n                                    \"catholic\",\n                                    \"orthodox\",\n                                    \"protestantism\",\n                                    \"nonbelief\",\n                                    \"islam\")\n\nqplot(x = maj_belief, data = countries)\n\n\n\n\nA je to! Sloupce jsou seřazeny. Ovšem manuálně vypisovat všechny kategorie je zdlouhavá záležitost. Lepší variantou je nechat R, aby pořadí úrovní určilo za nás. K tomu nejdříve budeme muset spočítat frekvenci výskytu jednotlivých kategorií. K tomu je možné využít již nám dobře známou kombinaci funkcí group_by() a summarise(). Uvnitř summarise() použijeme funkci n(), která vrátí počet pozorování v rámci dané skupiny.\n\ncountries %>%\n  group_by(maj_belief) %>% \n  summarise(n = n())\n\n# A tibble: 5 × 2\n  maj_belief        n\n  <fct>         <int>\n1 catholic         18\n2 orthodox          9\n3 protestantism     6\n4 nonbelief         3\n5 islam             2\n\n\nDalším krokem je zrušit seskupení a aplikovat funkci fct_reorder(), kde prvním argumentem je faktor a druhým proměnná, podle které úrovně faktoru seřadíme. Nakonec už jen zbývá aplikovat qplot(), tentokrát včetně argumentu y:\n\ncountries %>%\n  group_by(maj_belief) %>% \n  summarise(n = n()) %>% \n  ungroup() %>% \n  mutate(maj_belief = fct_reorder(maj_belief, n)) %>% \n  qplot(x = maj_belief, y = n, data = ., geom = \"col\")\n\n\n\n\nTento kód si zaslouží několik vysvětlivek. Zaprvé, protože se jedná o agregovaná data, je nutné specifikovat proměnnou pro osu Y(argument y). Dále je nutné fuknci qplot() říct, že výsledkem má být sloupcový graf (geom = col). Nakonec je nutné specifikovat, že náš dataframe má být dosazen do argumentu data a to pomocí placeholderu .. Vzpomeňme si, že s placeholdery jsme si již setkali, když jsme transformovali větší množství proměnných pomocí funkce across() (viz. Sekce 16.1).\n\n\n\n\n\n\ncount()\n\n\n\nPokud vám série funkci group_by() %>% summarise(n = n()) %>% ungroup() přijde zbytečně zdlouhavá, nejste sami. Autoři Tidyverse mají stejný názor a připravili pro nás proto funkci count(). Ta je v postatě je zkratkou pro výše zmíněnou sérii funkci. Následující skript tedy bude mít stejný výsledek, jako ten výše:\ncountries %>%\n  count(maj_belief) %>% \n  mutate(maj_belief = fct_reorder(maj_belief, n)) %>% \n  qplot(x = maj_belief, y = n, data = ., geom = \"col\")\n\n\nV našem posledním grafu jsou kategorie seřazené vzestupně. V našem původním datasetu jsou ovšem pořád sestupně. Pokud bychom chtěli pořadí kategorií obrátit, můžeme k tomu využít funkci fct_rev()\n\ncountries$maj_belief <- fct_rev(countries$maj_belief)\nqplot(x = maj_belief, data = countries)"
  },
  {
    "objectID": "faktory.html#transformace-úrovní",
    "href": "faktory.html#transformace-úrovní",
    "title": "17  Práce s faktory",
    "section": "17.3 Transformace úrovní",
    "text": "17.3 Transformace úrovní\nKromě řazení úrovní faktoru je také často budeme chtít transformovat. Nejčastěji tak, že budeme chtít změnit název úrovně. Jednou z úrovní naší proměnné maj_belief je protestantism, jejíž název morfologicky neodpovídá ostatním. Rádi bychom proto změnili název kategorie z protestantism na protestant. K tomu nám poslouží funkce fct_recode():\n\ncountries$maj_belief <- fct_recode(countries$maj_belief,\n                                   \"protestant\" = \"protestantism\")\n\nlevels(countries$maj_belief)\n\n[1] \"islam\"      \"nonbelief\"  \"protestant\" \"orthodox\"   \"catholic\"  \n\n\nJak je vidět, aplikace této funkce ja snadná, stačí specifikovat faktor, a v následujících argumentech poté názvy úrovni ve formátu nový název = starý název. Změnit je možné i více názvu najednou.\nKromě ručního přepisování názvů je možné měnit úrovně také programátorsky, pomocí funkce fct_relabel(). Pro hezčí vzhled našich grafů bychom například chtěli, aby název každé úrovně začínal velkým písmenem. Převedení prvních písmen na kapitálky je možné dosáhnout pomocí funkce str_to_title(). Nelze ji ale aplikovat přímo, jelikož tím bychom změnili formát proměnné z factor na character. Místo toho ji použijeme v kombinaci s fct_relabel(). Prvním argument je faktor samotný, druhým poté funkce, kterou chceme na názvy úrovní aplikovat:\n\ncountries$maj_belief <- fct_relabel(countries$maj_belief, str_to_title)\n\nlevels(countries$maj_belief)\n\n[1] \"Islam\"      \"Nonbelief\"  \"Protestant\" \"Orthodox\"   \"Catholic\"  \n\n\nPoslední transformací, kterou si zde ukážeme, je kolapsování kategorií. I to lze provádět jak ručně, tak programátorsky. První variantou je fct_collapse(), pomocí které můžeme například sloučit existující kategorie Protestant, Catholic a Orthodox do nové kategorie Christian:\n\ncountries$maj_belief_collapsed <-  fct_collapse(countries$maj_belief,\n                                                Christianity = c(\"Protestant\",\n                                                                 \"Catholic\",\n                                                                 \"Orthodox\"))\n\nlevels(countries$maj_belief_collapsed)\n\n[1] \"Islam\"        \"Nonbelief\"    \"Christianity\"\n\n\nAlternativou je slučování na základě četností pomocí funkce fct_lump(). Pro sloučení všech kategorií, kromě tří nejpočetnějších lze využít argument n:\n\ncountries$maj_belief_n <- fct_lump(countries$maj_belief,\n                                   n = 3,\n                                   other_level = \"Other\")\n\nlevels(countries$maj_belief_n)\n\n[1] \"Protestant\" \"Orthodox\"   \"Catholic\"   \"Other\"     \n\n\nObdobně, pro sloučení všech kategorií, které netvoří alespoň 20 % všech pozorovaných hodnot, lze využít argument prop:\n\ncountries$maj_belief_prop <- fct_lump(countries$maj_belief,\n                                   prop = 0.2,\n                                   other_level = \"Other\")\n\nlevels(countries$maj_belief_prop)\n\n[1] \"Orthodox\" \"Catholic\" \"Other\""
  },
  {
    "objectID": "stringy.html#detekce-stringů",
    "href": "stringy.html#detekce-stringů",
    "title": "18  Práce se stringy",
    "section": "18.1 Detekce stringů",
    "text": "18.1 Detekce stringů\nNáš data frame countries obsahuje proměnnou hd_title_name. Jedná se o titula a jméno hlavy dané země (k roku 2018). Na rozdíl od ostatních kategoriálních proměnných jsou jak titul, tak jméno osoby v jednom sloupci. Práce s nimi tedy bude vyžadovat o něco jiný přístup, než na jaký jsme zvyklí.\nJedním z nejběžnějších úkonů je vyhledávání vzorců (patterns) v textu. Pro vybraní zemí, jejichž hlavou je král, je možné zkombinovat již známou funkci filter() s funkcí str_detect(). Tato funkce vrátí hodnotu TRUE pro všechny řádky, ve kterých se nachází zvolený vzorec znaků, v našem případě “King”:\n\ncountries %>% \n  filter(str_detect(hd_title_name, pattern = \"King\")) %>% \n  select(country, hd_title_name)\n\n# A tibble: 5 × 2\n  country     hd_title_name          \n  <chr>       <chr>                  \n1 Belgium     King - Philippe        \n2 Spain       King - Felipe VI       \n3 Netherlands King - Willem-Alexander\n4 Sweden      King - Carl XVI Gustaf \n5 Norway      King - Harald V        \n\n\nPomocí stejné funkce je možné hledat i více vzorců na jednou. Pro vyhledání všech království našem datasetu vyhledáme všechny hlavy států s titulem “King” nebo “Queen”. Oba hledané vzorce oddělíme znakem |, značící logický operátor OR:\n\ncountries %>% \n  filter(str_detect(hd_title_name, pattern = \"King|Queen\")) %>% \n  select(country, hd_title_name)\n\n# A tibble: 7 × 2\n  country        hd_title_name          \n  <chr>          <chr>                  \n1 Belgium        King - Philippe        \n2 Denmark        Queen - Margrethe II   \n3 Spain          King - Felipe VI       \n4 Netherlands    King - Willem-Alexander\n5 Sweden         King - Carl XVI Gustaf \n6 United Kingdom Queen - Elizabeth II   \n7 Norway         King - Harald V        \n\n\nV některých případech nám bude stačit vědět, kolikrát se určitý vzorec vyskytuje v datech. K tomu využijeme funkci str_count(). Protože pracujeme s vektorem stringů, zkombinujeme ji s funkcí sum(), abychom získali celkový počet monarchů napří všemi zeměmi:\n\nsum(str_count(countries$hd_title_name, pattern = \"King|Queen\"))\n\n[1] 7"
  },
  {
    "objectID": "stringy.html#separace-stringů",
    "href": "stringy.html#separace-stringů",
    "title": "18  Práce se stringy",
    "section": "18.2 Separace stringů",
    "text": "18.2 Separace stringů\nPro usnadnění budoucí práce by bylo lepší proměnnou hd_title_name rozdělit do dvou nových proměnných. První z nových proměnných bude titul hlavy státu (title), druhou poté samotné jméno státnika (name). Toho nejjednodušeji docíleme pomocí funkce separate() z balíčku tidyr. Prvním argumentem této funkce, je string, který chceme rozdělit. Druhým argumentem, into, je vektor obsahující jména nových proměnných. Třetím argumentem je separátor (sep), který rozděluje obsah první a druhé z nových proměnných:\n\ncountries %>% \n  select(hd_title_name) %>% \n  separate(hd_title_name,\n           into = c(\"title\", \"name\"),\n           sep = \"-\") %>% \n  head(5)\n\nWarning: Expected 2 pieces. Additional pieces discarded in 4 rows [5, 11, 19,\n30].\n\n\n# A tibble: 5 × 2\n  title      name           \n  <chr>      <chr>          \n1 King       \" Philippe\"    \n2 President  \" Rumen Radev\" \n3 President  \" Miloš Zeman\" \n4 Queen      \" Margrethe II\"\n5 President  \" Frank\"       \n\n\nTento kód téměř funguje, jak má, s jedním drobným problémem. Jak nás upozorňuje varování Warning: Expected 2 pieces. Additional pieces discarded in 4 rows [5, 11, 19, 30]. v několika jménech se objevil náš separátor - více než jednou. Protože jsme ale specifikovali pouze dvě nové proměnné, title a name, zahodili jsme omylem část jmen na řádcích 5, 11, 19 a 30. Napravit to můžeme pomocí argumentu extra = \"merge\", pomocí kterého zachováme všechny jména celé:\n\ncountries %>% \n  select(hd_title_name) %>% \n  separate(hd_title_name,\n           into = c(\"title\", \"name\"),\n           sep = \"-\",\n           extra = \"merge\") %>%\n  head(5)\n\n# A tibble: 5 × 2\n  title      name                      \n  <chr>      <chr>                     \n1 King       \" Philippe\"               \n2 President  \" Rumen Radev\"            \n3 President  \" Miloš Zeman\"            \n4 Queen      \" Margrethe II\"           \n5 President  \" Frank-Walter Steinmeier\""
  },
  {
    "objectID": "stringy.html#sec-string-transformations",
    "href": "stringy.html#sec-string-transformations",
    "title": "18  Práce se stringy",
    "section": "18.3 Transformace stringů",
    "text": "18.3 Transformace stringů\nV některých případech je nutné stringy transformovat, buď do podoby vhodné pro analýzy nebo naopak do podoby vhodné pro prezentaci výstupů. Balíček stringr pro transformaci stringů nabízí hned několik funkcí. Funkce str_to_lower() převede všechny písmena na malá, str_to_upper() naopak na velká. str_to_sentence() převede první písmeno na velké a zbytek na malá, a nakonec str_to_title() převede první písmeno každého slova na velké a zbytek na malá:\n\nstr_to_lower(countries$hd_title_name) %>% head(5)\n\n[1] \"king - philippe\"                     \"president - rumen radev\"            \n[3] \"president - miloš zeman\"             \"queen - margrethe ii\"               \n[5] \"president - frank-walter steinmeier\"\n\nstr_to_upper(countries$hd_title_name) %>% head(5)\n\n[1] \"KING - PHILIPPE\"                     \"PRESIDENT - RUMEN RADEV\"            \n[3] \"PRESIDENT - MILOŠ ZEMAN\"             \"QUEEN - MARGRETHE II\"               \n[5] \"PRESIDENT - FRANK-WALTER STEINMEIER\"\n\nstr_to_sentence(countries$hd_title_name) %>% head(5)\n\n[1] \"King - philippe\"                     \"President - rumen radev\"            \n[3] \"President - miloš zeman\"             \"Queen - margrethe ii\"               \n[5] \"President - frank-walter steinmeier\"\n\nstr_to_title(countries$hd_title_name) %>% head(5)\n\n[1] \"King - Philippe\"                     \"President - Rumen Radev\"            \n[3] \"President - Miloš Zeman\"             \"Queen - Margrethe Ii\"               \n[5] \"President - Frank-Walter Steinmeier\""
  },
  {
    "objectID": "obsah-grafu.html#sec-grammar-of-graphics",
    "href": "obsah-grafu.html#sec-grammar-of-graphics",
    "title": "19  Struktura grafů",
    "section": "19.1 Grammar of graphics",
    "text": "19.1 Grammar of graphics\nAčkoliv to nemusí být na první pohled zřejmé, i vizalizace dat je předmětem vědeckého výzkumu a teorie. Teoretické základy balíčku ggplot2 leží v takzvané “grammar of graphics” (Wilkinson, 2005). Základnímí pilíři tohoto paradigmatu, tak jak je implementované zde, jsou takzvané scales, geoms a themes:\n\nScales jsou dimenze grafu, v kterých se nachází data. Jedná se osy grafu, ale také například o barvu nebo velikost.\nGeoms jsou objekty, které fyzicky reprezentují data v grafu. Jde například o sloupce ve sloupcovém grafu nebo body v bodovém grafu.\nThemes kontrolují estestickou stránku grafu, jako velikost nebo font písma, barvu pozadí nebo zda jsou v grafu přítomné vodicí přímky."
  },
  {
    "objectID": "obsah-grafu.html#struktura-ggplot2-grafů",
    "href": "obsah-grafu.html#struktura-ggplot2-grafů",
    "title": "19  Struktura grafů",
    "section": "19.2 Struktura ggplot2 grafů",
    "text": "19.2 Struktura ggplot2 grafů\nJednotlivé složky se na sebe nanášejí ve vrstvách (layers). Tvorba každého grafu bude začínat funkcí ggplot():\n\nggplot(data = countries)\n\n\n\n\nFunkce ggplot() vyžaduje minimálně argument data, pomocí kterého specifikujeme náš dataframe. Výsledkem je prázdné plátno. Druhým krokem je specifikovat dimenze (scales) našeho grafu. Toho docíleme pomocí funkce aes() (zkratka pro aesthetics) a argumentu mapping:\n\nggplot(data = countries,\n       mapping = aes(x = hdi, y = life_exp))\n\n\n\n\nPomocí funkce aes() jsme definovali dvě dimenze (scales). Ose X jsme přiřadili proměnnou hdi, a na osu Y jsme “namapovali” proměnnou life_exp. Výsledkem je graf s popsanými osami, nicméně pořád bez dat.\n\n\n\n\n\n\nMapování\n\n\n\nSlovo “mapovat” je zde používané v matematickém významu, tedy ve smyslu přiřazování elementů jednoho setu k elementům druhého setu. V našem případě přiřazujeme proměnné v datech k dimenzím v grafu. Od toho je odvozeno také jméno argumentu mapping.\n\n\nDalším krokem je přidání geomů, tedy objektů, které budou reprezentovat jednotlivé pozorování. V našem případě se nabízí zobrazit jednotlivé země jako body, využijeme tedy funkce geom_point():\n\nggplot(data = countries,\n       mapping = aes(x = hdi, y = life_exp)) +\n  geom_point()\n\n\n\n\nVýsledkem je starý známý bodový graf (scatter plot), ve kterém je každý řádek dataframu reprezentovaný bodem. Posledním krokem je úprava vizuální stránky grafu, jako například barvy pozadí, Toho docílíme pomocí funkce themes(), která má řadu argumentů, mezi nimi i panel.background. Na to, jak přesně tato funkce funguje, se zaměříme v budoucích kapitolách:\n\nggplot(data = countries,\n       mapping = aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  theme(panel.background = element_rect(fill = \"#fff6e5\"))\n\n\n\n\nA to je v podstatě celá logika balíčku ggplot2! V následujících kapitolách si představíme nejpoužívánější dimenze/scales a geomy, a ponoříme se také do fungování funkce theme()."
  },
  {
    "objectID": "kategoricke-grafy.html#vizualizace-jedné-proměnné",
    "href": "kategoricke-grafy.html#vizualizace-jedné-proměnné",
    "title": "20  Vizualizace kategorických proměnných",
    "section": "20.1 Vizualizace jedné proměnné",
    "text": "20.1 Vizualizace jedné proměnné\nZačněme vizualizací jedné kategoriální proměnné. Sloupcové grafy jsou pravděpodobně nejpopulárnějším typem vizualizace, se kterým se setkáme. Pro vytvoření sloupcového grafu je dobré si vybavit, ktteré proměnné se nachází na jednotlivých osách. Na ose X se nachází název kategorie, na ose Y poté frekvence výskyty. Vstupními daty pro funkci ggplot() bude tedy dataframe s těmito dvěmi proměnnými. Data budou reprezentovaná pomocí sloupců, které přidáme funkcí geom_col():\n\ncountries %>% \n  count(postsoviet) %>% \n  ggplot(aes(x = postsoviet, y = n)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\ngeom_bar()\n\n\n\nPokud je cílem našeho sloupcového grafu zobrazit (absolutní) četnost jednotlivých kategorií, můžeme nahradit geom_col() funkcí geom_bar(), která automaticky frekvenci výskytu všech skupin. Celý kód by vypadal následovně:\n\nggplot(countries,\n       aes(x = postsoviet)) +\n  geom_bar()\n\n\n\nPokud bychom v grafu chtěli zobrazit relativní frekvenci výskytu kategorií, spočítáme percentuální zastoupení před vytvořením grafu.\n\ncountries %>% \n  count(postsoviet) %>% \n  mutate(freq = n / sum(n)) %>% \n  ggplot(aes(x = postsoviet, y = freq)) +\n  geom_col()\n\n\n\n\n\n\n\n\n\n\nOrientace grafu\n\n\n\nNázvy kategorií nemusí být nutně na ose X. Pro otočení grafu o 90 stupňů stačí použít ggplot(aes(x = freq, y = postsoviet)).\n\n\nDo grafu také můžeme přidat popisky jednotlivých sloupců. Nejdříve je nutné napojit proměnou obsahující frekvenci jednotlivých kategorií na dimenzi label. Popisky přidáme do grafu pomocí funkcec geom_text():\n\ncountries %>% \n  count(postsoviet) %>% \n  mutate(freq = n / sum(n)) %>% \n  ggplot(aes(x = postsoviet, y = freq, label = freq)) +\n  geom_col() + \n  geom_text()\n\n\n\n\nVýsledkem je funkční, ale nepříliš vzhledný graf. Aby náš graf byl použitelný, je nutné čísla v popiscích zaoukrouhlit a popisky samotné posunout tak, aby nepřekrývali sloupce. Zaokrouhlení dosáhneme pomocí funkce round(), kterou můžeme aplikovat přímo uvnitř funkce ggplot(). Pro posunutí popisků na vertikální ose je možné využít argument vjust uvnitř funkce geom_text(), k posouvání na horizontální ose poté slouží hjust. Hodnoty argumentů vjust a hjust jsou ve stejných jednotkách, jako proměnná na dané ose.\n\ncountries %>% \n  count(postsoviet) %>% \n  mutate(freq = n / sum(n)) %>% \n  ggplot(aes(x = postsoviet, y = freq, label = round(freq, 2)) ) +\n  geom_col() + \n  geom_text(vjust = -0.5)"
  },
  {
    "objectID": "kategoricke-grafy.html#vizualizace-více-proměnnýchných",
    "href": "kategoricke-grafy.html#vizualizace-více-proměnnýchných",
    "title": "20  Vizualizace kategorických proměnných",
    "section": "20.2 Vizualizace více proměnnýchných",
    "text": "20.2 Vizualizace více proměnnýchných\nPro vizualizaci většího počtu proměnných pomocí sloupcových grafů zpravidla využíváme barev, pro rozlišení jednotlivých kategorií. Jedna kategorická proměnná bude tedy namapovaná na osu X, druhá poté na barvu sloupce. Frekvence dané kategorie bude na ose Y:\n\ncountries %>% \n  count(postsoviet, eu_member) %>% \n  ggplot(aes(x = postsoviet, fill = eu_member, y = n)) +\n  geom_col()\n\n\n\n\nVšimněme si, že v našem grafu jsou nyní jednotlivé kategorie naskládány na sebe. Jejich pozici je možné upravovat pomocí argumentu position, pro který je výchozí hodnota position = \"stack\". První alternativou je argument = \"fill\", který je obdobný stack, ale velikost sloupců je standardizována. Graf tedy zobrazuje relativní frekvenci jednotlivých kategorií:\n\ncountries %>% \n  count(postsoviet, eu_member) %>% \n  ggplot(aes(x = postsoviet, fill = eu_member, y = n)) +\n  geom_col(position = \"fill\")\n\n\n\n\nStejně jako u jednoduchého sloupcového grafu, i do skládáných grafů je možné přidat popisky. Je ale nutné sladit jejich pozici s pozicí sloupců. Pokud jsme jako sloupců zvolili position = \"fill\", je nutné stejnou pozici zvolit i pro popisky. Také je nutné popisky zarovnat doprostřed jednotlivých dlaždic. Obojího docíleme pomocí position = position_fill(vjust = 0.5):\n\ncountries %>% \n  count(postsoviet, eu_member) %>% \n  ggplot(aes(x = postsoviet, fill = eu_member, y = n, label = n)) +\n  geom_col(position = \"fill\") +\n  geom_text(position = position_fill(vjust = 0.5))\n\n\n\n\nDruhou alternativou je position = \"dodge\", pomocí které je možné vyskládat jednotlivé sloupce vedle sebe. Obdobně jako u předchozí varianty přidáme popisky, tentokrát ale pomocí position_dodge(). jednotlivé sloupce jsou od sebe zpravidla vzdálené jednu “jednotku”. Stejně jako u jednoduchého grafu také popisky posuneme lehce nahoru:\n\ncountries %>% \n  count(postsoviet, eu_member) %>% \n  ggplot(aes(x = postsoviet, fill = eu_member, y = n, label = n)) +\n  geom_col(position = \"dodge\") +\n  geom_text(position = position_dodge(width = 1), vjust = -0.5)\n\n\n\n\nAlternativou klasických sloupcových grafů je heat map. Pro vytvoření heat mapy nejdříve získáme frekvenci výskytu kombinací jednotlivých kategorií, obdobně jako když jsme vytvářeli sloupcový graf. Poté jen napojíme jednu z kategorických proměnných na osu X, druhou na osu Y a frekvenci výskytu na barvu jednotlivých “dlaždic”. Graf dokončíme pomocí funkce geom_tile(). Stejně jako v předchozích grafech můžeme přidat popisky pro jednotlivé dlaždice pomocí geom_text().\n\n\n\n\n\n\nChybějící kombinace kategorií\n\n\n\nV případě, že se v naši datech nevyskytují některé kombinace kategorií, je nutné proměnné převést na faktory a do funkce count() přidáme argument .drop = FALSE. Pokud bychom to neudělali, objevily by se v naší heat mapě mezery.\n\n\n\ncountries %>% \n  mutate(across(c(maj_belief, postsoviet),\n                as.factor)) %>% \n  count(postsoviet, maj_belief, .drop = F) %>% \n  ggplot(aes(x = postsoviet, y = maj_belief,\n             label = n, fill = n)) +\n  geom_tile() +\n  geom_text(color = \"white\")"
  },
  {
    "objectID": "numericke-grafy.html#vizualizace-jedné-proměnné",
    "href": "numericke-grafy.html#vizualizace-jedné-proměnné",
    "title": "21  Vizualizace numerických proměnných",
    "section": "21.1 Vizualizace jedné proměnné",
    "text": "21.1 Vizualizace jedné proměnné\nNumerické proměnné jsou zpravidla vizualizovány pomocí histogramu, tedy sloupcové grafu, který zobrazuje frekvenci jednotlivých hodnot shluknutých do menšího počtu kategorií (v angličtěně zvaných bins). Vytvoření histogramu je přímočaré:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_histogram()\n\n\n\n\nPočet kategorií je možné kontrolovat pomocí jednoho ze dvou argument. Prvním z nich je bins, pomocí kterého je možné kontrolovat celký počet kategorií. Například, pro 15 kategorií zvolíme následující:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_histogram(bins = 15)\n\n\n\n\nDruhým argumentem je binwidth, pomocí kterého je možné specifikovat šířku jednotlivých kategorií. Pokud chceme, aby kategorie měli šířku jednoho (v našem případě) roku, použijeme následující kód:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_histogram(binwidth = 1)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nNěkteří lidé preferují, když jsou jednotlivé kategorie (bins) vizuálně oddělené. Toho můžeme docílit tak, že nastavíme barvu manuálně:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_histogram(binwidth = 1, color = \"white\")\n\n\n\n\n\n\nAlternativou k histogramu je graf hustoty (density plot). Ty na rozdíl od histogramů nekategorizují vizualizovanou proměnnou, místo toho odhadují podobu spojitého rozdělení, kterou proměnná nabývá:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_density()\n\n\n\n\nMíru “vyhlazení” (smoothing) grafu hustoty je možné kontrolovat pomocí argument bw (bandwidth zkráceně). Nižší hodnoty povedou k menšímu vyhlazení. Někteří také mohou preferovat, pokud je plocha pod křivkou hustoty vybarvené, čehož lze docílit pomocí argumentu fill:\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_density(bw = 0.25, fill = \"grey50\")\n\n\n\n\nPoslední možností je boxplot, který zobrazuje vybrané kvartily proměnné. Hranice krabice “krabice” zobrazují první a třetí kvartil, úsečka uvnitř krabice reprezentuje medián a “fousky” grafu reprezentují mezikvartilové rozpětí vynásobené konstantou (zpravidla 1,5):\n\nggplot(countries,\n       aes(x = life_exp)) +\n  geom_boxplot()\n\n\n\n\nZ grafu výše je možné vyčíst, že medián naděje na dožití našich zemí je 81 let. První kvartil je zhruba 76,8 let a třetí kvartil je zhruba 81,5 let. Fousky grafy, které zpravidla reprezentují hranice pro odlehlá pozorování mají hodnoty 74,8 a 83,2 let."
  },
  {
    "objectID": "numericke-grafy.html#vizualizace-více-proměnných",
    "href": "numericke-grafy.html#vizualizace-více-proměnných",
    "title": "21  Vizualizace numerických proměnných",
    "section": "21.2 Vizualizace více proměnných",
    "text": "21.2 Vizualizace více proměnných\nVztah dvou numerických proměnných je typicky zobrazen pomocí bodového grafu, známého také jako scatterplot. Pro vytvoření bodového grafu stačí přiřadit jednu proměnnou na osu X a druhou na osu Y. Poté jen zobrazíme data pomocí funkce geom_point():\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point()\n\n\n\n\nPro lepší přehled může být užitečné přidat křivku vyjadřující vztah mezi proměnnými. Balíček ggplot2 na to poskytuje užitečnou funkci zvanou geom_smooth(). Ve výchozím nastavení tato funkce zobrazí křivku reprezentující takzvanou localy estimated scatterplot smoothing (loess) regresi, neparametrickou techniku pro popis vztahů mezi numerickými proměnnými, včetně 95 % intervalů spolehlivosti:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  geom_smooth()\n\n\n\n\nKromě loess regrese můžeme aplikovat také klasickou lineární regresi, pomocí argumentu method = \"lm\" . Také se můžeme zbavit intervalů spolehlivosti pomocí se = FALSE:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE)"
  },
  {
    "objectID": "kombinovane-grafy.html#boxploty",
    "href": "kombinovane-grafy.html#boxploty",
    "title": "22  Kombinované grafy",
    "section": "22.1 Boxploty",
    "text": "22.1 Boxploty\nPro vytvoření boxplotu pro větší počet skupin stačí přidat kategorickou proměnnou na jednu z os:\n\nggplot(countries,\n       aes(x = postsoviet, y = life_exp)) +\n  geom_boxplot()"
  },
  {
    "objectID": "kombinovane-grafy.html#bodové-grafy",
    "href": "kombinovane-grafy.html#bodové-grafy",
    "title": "22  Kombinované grafy",
    "section": "22.2 Bodové grafy",
    "text": "22.2 Bodové grafy\nV případě, že jsou obě osy grafu obsazeny numerickými proměnnými, jako je to například v případě bodových grafů, musí být kategorické proměnné namapované na jiné dimenze. Nejčastějším kandidátem je barva:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = postsoviet)) +\n  geom_point() \n\n\n\n\nCo kdybychom chtěli ale do grafu zapojit více proměnných? V takovém případě můžeme využít dimenzí tvaru (shape) a velikosti (size). Získáme tak (poněkud překombinovaný) graf zobrazující až pět proměnných:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = postsoviet,\n           shape = eu_member, size = gdp)) +\n  geom_point() \n\n\n\n\nPoznámku si zaslouží bodové grafy obsahující regresní přímky (nebo křivky) vytvořené pomocí geom_smooth(). Ve výchozím nastavení bude do grafu přidána přímka pro každou kategorii:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = postsoviet)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\nPokud bychom chtěli jednu přímku pro celý graf, je nutné přidat, argument group = 1, pomocí kterého řekneme grafu, že pro potřeby výpočtu vlastností přímky patří všechna pozorování do jedné skupiny:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = postsoviet, group = 1)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")"
  },
  {
    "objectID": "kombinovane-grafy.html#sec-grouped-histograms",
    "href": "kombinovane-grafy.html#sec-grouped-histograms",
    "title": "22  Kombinované grafy",
    "section": "22.3 Histogramy a grafy hustoty",
    "text": "22.3 Histogramy a grafy hustoty\nZapojení kategorických proměnných do histogramů probíhá obdobně, jako u bodových grafu, a využijeme k tomu dimenzi barvy.\n\nggplot(countries,\n       aes(x = life_exp, fill = postsoviet)) +\n  geom_histogram()\n\n\n\n\nU grafů hustoty je situace o něco komplikovanější, protože rozdělení se mohou překrývat. V grafu níže tak nevidíme dvě západní země s nízkou nadějí na dožití:\n\nggplot(countries,\n       aes(x = life_exp, fill = postsoviet)) +\n  geom_density()\n\n\n\n\nŘešením je zvýšit průhlednost rozdělení, čehož docílíme pomocí argumentu alpha. Ten může nabývat hodnot od 0 do 1, kde 0 je naprosto průhledná a 1 je naprosto neprůhledná:\n\nggplot(countries,\n       aes(x = life_exp, fill = postsoviet)) +\n  geom_density(alpha = 0.5)"
  },
  {
    "objectID": "facety.html#jednorozměrné-facety",
    "href": "facety.html#jednorozměrné-facety",
    "title": "23  Facety",
    "section": "23.1 Jednorozměrné facety",
    "text": "23.1 Jednorozměrné facety\nRozdělení grafu na facety je přímočaré, stačí k normálnímu grafu připojit funkci facet_wrap(). Uvnitř ní je poté nutné specifikovat kategorickou proměnnou, podle které se budou facety dělit. Tato proměnná je zadaná v, na první pohled zvláštním formátu, jelikož ji vždy musí předcházet tilda (~). Proč tomu tak je bude jasnější, až začneme vytvářet facety na základě více proměnných:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  facet_wrap(~postsoviet)\n\n\n\n\nVýsledkem jsou dva menší grafy, jeden pro západní země (nadepsaný no) a druhý po postsovětské (yes). Ve výchozím nastavení sdílí všechny dílčí grafy stejné rozpětí os. Změnit to můžeme pomocí argumentu scale. Pokud bychom chtěli, aby každý z facet měla svou vlastní horizontální osu, použijeme scale = \"free_x\". Analogicky, pro vlastní vertikální osu je možné aplikovat scale = \"free_y\". Pokud mají všechny dílčí grafy mít své vlastní osy, využijeme scale = \"free\":\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  facet_wrap(~postsoviet,\n             scales = \"free\")"
  },
  {
    "objectID": "facety.html#vícerozměrné-facety",
    "href": "facety.html#vícerozměrné-facety",
    "title": "23  Facety",
    "section": "23.2 Vícerozměrné facety",
    "text": "23.2 Vícerozměrné facety\nFacety je možné vytvářet na základě více než jedné proměnné, a to hned dvěma způsoby. Tím prvním je využít již známou funkcí facet_wrap():\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  facet_wrap(~postsoviet + maj_belief)\n\n\n\n\nPočet řádků v “tabulce” grafů je možné kontrolovat pomocí argumentu nrow, pro počet sloupců poté analogicky ncol. Tímto způsobem můžeme vytvořit facetu pro každou kombinaci kategorií obou proměnných. V takto nestruktorovaných facetách může ovšem být obtížné se zorientovat. Lepší variantou proto může být funkce facet_wrap(). I ta vytváří facety pro každou kombinaci kategorií, organizuje je ale do tabulky. U této funkce je také nejvíce zřejmé, proč se při vytváření facet využívá tilda (~). Jedná se totiž o formuli, pomocí které definujeme vztah mezi proměnnými. V našem případě je výsledná tabulka facet založená na vztahu proměnných postsoviet a maj_belief:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  facet_grid(postsoviet~maj_belief)"
  },
  {
    "objectID": "vzhled-grafu.html#barvy",
    "href": "vzhled-grafu.html#barvy",
    "title": "24  Vzhled grafů",
    "section": "24.1 Barvy",
    "text": "24.1 Barvy\nBarvy jsou v R specifikované pomocí hex kódů, tedy kombinace znaku # a šesti dalších číslic a písmen. Napříkad černé barvě přísluší kód #000000, zatímco bílá #ffffff. Kódy barev jsou dostupné na mnoha místech, jakým je třeba stránka https://www.color-hex.com. Uživatelé Rstudia mohou také využít balíček colourpicker, přidávající šikovný addin (rozšíření) Rstudio, pomocí kterého je výběr barev nadmíru snadný.\nNejjednoduší je změnit barev všech sloupců najednou. Předtím, než se do toho pustíme, je ale třeba si ujasnit rozdíl mezi argumenty color a fill. Většina objektů (geomů) pomocí kterých ggplot2 je složena ze dvou částí: obrysu a výplně. Barvu obrysu kontrolujeme pomocí argumentu color, barvu výplně pomocí fill. Protože u sloupcových grafů je dominantní výpln sloupců, použijeme pro změnu vzhledu právě argument fill, a to přímo uvnitř funkce geom_col():\n\nggplot(dem_countries,\n       aes(x = di_cat, y = freq)) +\n  geom_col(fill = \"#008080\")\n\n\n\n\nKomplexnějším úkonem je aplikace palety barev. Základní nabídku palet, kterou přínáší balíček RColorBrewer, je možné zobrazit pomocí funkce display.brewer.all() (nesmíme ale zapomentou nejdříve balíček aktivovat!):\n\nlibrary(RColorBrewer)\n\ndisplay.brewer.all()\n\n\n\n\nPalety jsou rozděleny do tří skupin. První skupinou jsou takzvané sequential palety, tedy palety vhodné pro vizualizaci stupňující se intenzity. Hodí se zejména pro jednopolární proměnné, kde nula reprezentuje absenci, jako například podíl nezaměstnaných. Druhou skupinou jsou qualitative palety, vhodné pro nominální proměnné, jako je převažující náboženská skupina v zemi. Poslední skupinou jsou diverging palety, určené pro bipolární proměnné. Tato skupina palet je vhodná pokud nízké hodnoty reprezentují opak vysokých hodnot. Příkladem bipolární proměnné je například škála demokracie-autoritářství.\nPro aplikaci palety musíme nejdřív jednotlivé kategorie na ose X namapovat na barvu výplně (fill). Poté ke zbytku kódu přidáme funkci scale_fill_brewer(). Ta je součástí širší rodiny funkcí, začínajících slovem scale_, které kontrolují vzhled jednotlivých dimenzí. Jelikož v tuto chvíli pracujeme s dimenzí fill, používáme skupinu funkcí scale_fill. A protože je naším cílem využít paletu z RColorBrewer, funkce kterou hledáme je právě scale_fill_brewer():\n\nggplot(dem_countries,\n       aes(x = di_cat, y = freq, fill = di_cat)) +\n  geom_col() +\n  scale_fill_brewer(palette = \"RdYlGn\")\n\n\n\n\nFunkce scale_color_brewer() má několik užitečných argumentů. Prvním z nich je direction, pomocí které je možné kontrolovat orientaci barev. V našem případě by bylo pravděpodobně vhodnější, aby země s rozvinutější mírou demokracie byly označeny zeleně. Toho docílíme pomocí direction = -1. Druhým z užitečných argumentů je na.value, pomocí které je možné kontrolovat barvu sloupce reprezentující chybějící hodnoty (NA). V tuto chvíli ja barva NA sloupce stejná jako barva pozadí grafu, což není úplně ideální. Použijeme proto tmavší odstín šedé, s hex kódem #696868:\n\nggplot(dem_countries,\n       aes(x = di_cat, y = freq, fill = di_cat)) +\n  geom_col() +\n  scale_fill_brewer(palette = \"RdYlGn\", \n                    direction = -1,\n                    na.value = \"#696868\")\n\n\n\n\nPokud nám nevyhovuje žádná z předpřipravených palet, je možné barvy jednotlivých kategorií zadat i ručně, k čemuž využijeme funkce scale_fill_manual():\n\nggplot(dem_countries,\n       aes(x = di_cat, y = freq, fill = di_cat)) +\n  geom_col() +\n  scale_fill_manual(values = c(\"#00688B\", \"#009ACD\", \"#00BFFF\", \"#7D7D7D\"))\n\n\n\n\nNakonec je dobré zmínit ještě speciální typ barevných palet, takzvané continuous palety. Ty slouží k barevné vizualizaci spojitých proměnných. ggplot2 nabízí dvě continuous palety, gradient pro unipolární proměnné a viridis pro bipolární. Obě je možné aplikovat pomocí funkcí scale_color_continuous() nebo scale_fill_continuous() podle toho, zda jde o barvu obrysu nebo barvu výplně:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  scale_color_continuous(type = \"viridis\")\n\n\n\n\nPokud nám nevyhovuje žádná z palet, je možné zvolit barvy vlastní, a to hned dvěma způsoby. Prvním možností je funkce scale_color_gradient() (případně scale_fill_gradient()), pomocí které můžeme barvu minima a maxima. Funkce interpoluje barvu zbylých hodnot:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  scale_color_gradient(low = \"#33A02C\", high = \"#E31A1C\")\n\n\n\n\nDruhou možností je funkce scale_color_gradient2() (a analogicky scale_fill_gradient2()), pomocí které je možné specifikovat tři barvy: minima, maxima a středu. Poté jen stačí specifikovat střední hodnotu barevné škály:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  scale_color_gradient2(low = \"#33A02C\", mid = \"#D6D62D\", high = \"#E31A1C\",\n                        midpoint = 0.25)"
  },
  {
    "objectID": "vzhled-grafu.html#tvar",
    "href": "vzhled-grafu.html#tvar",
    "title": "24  Vzhled grafů",
    "section": "24.2 Tvar",
    "text": "24.2 Tvar\nU některých geomů, například geom_point(), je možné určit určit jejich tvar a to pomocí argumentu shape. R obsahuje 26 základních tvarů, které je aplikovat pomocí jejich číselných kód. Vychozím tvarem je ten s hodnotou 1:\n\n\n\n\n\nTvar objektů je možné specifikovat pomocí stejných pravidel, jako jejich barvu. Plošně je možné zvolit tvar pomocí argumentu shape, v případě škál bychom využili funkce scale_shape_manual():\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point(shape = 24)"
  },
  {
    "objectID": "vzhled-grafu.html#velikost-a-průhlednost",
    "href": "vzhled-grafu.html#velikost-a-průhlednost",
    "title": "24  Vzhled grafů",
    "section": "24.3 Velikost a průhlednost",
    "text": "24.3 Velikost a průhlednost\nPrůhlednost objektu je možné upravovat argumentem alpha, se kterým jsme již letmo setkali v předchozí kapitole (Sekce 22.3). alpha nabývá hodnot od 0 (zcela průhledná) do 1 (zcela neprůhledné). Argument size poté slouží ke kontrolove velikosti geomů a může nabývat jakkékoliv pozitivní hodnoty:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point(alpha = 0.5, size = 3)"
  },
  {
    "objectID": "vzhled-grafu.html#formátování-os",
    "href": "vzhled-grafu.html#formátování-os",
    "title": "24  Vzhled grafů",
    "section": "24.4 Formátování os",
    "text": "24.4 Formátování os\nO formátování vertikální a horizontální osy stará rodina funcí scale_x a scale_y. Pokud je na dané ose numerická proměnná, použijeme funkci scale_x_continuous() (resp. scale_y_continuous()). Pokud jde o proměnnou kategorickou, využijeme funkcí scale_x_discrete() a scale_y_discrete().\nU numerických proměnných jsou dvěma nejužívanějšími argumenty limits a breaks. Prvním z nich lze určit rozpětí osy, a to vektorem obsahujícím spodní a horní limit. Pokud bychom chtěli omezit rozpětí horizontální osy mezi hodnotami 0.5 a 1, použijeme limits = c(0.5, 1). Pro určení pouze jednoho z limitů nahradíme druhou hodnotu NA, např. c(NA, 1). Druhým argementem, breaks, poté upravíme hodnoty, které se na ose ukazují:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  scale_x_continuous(limits = c(0.5, 1)) +\n  scale_y_continuous(breaks = 76:83)\n\n\n\n\nKromě toho, jaké hodnoty se na osách zobrazí, je možné upravovat i jejich formát. K tomu nám pomůže balíček scales, v kombinaci s argumentem labels. Tento balíček obsahuje sadu funkcí, jako například number_format(), percent_format() nebo date_format(). Funkcí number_format() můžeme přidat prefix (argument prefix()), sufix (sufix), převést proměnnou na jiné jednotky (scale) nebo upravit počet desetinných míst accuracy a jejich oddělovač (decimal.mark). Funkce percent_format() funguje obdobně, automaticky ale také převádí desetinná čísla na procenta:\n\nlibrary(scales)\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  scale_x_continuous(limits = c(0.5, 1),\n                     labels = percent_format(accuracy = 1, suffix = \" %\")) +\n  scale_y_continuous(breaks = 76:83,\n                     labels = number_format(suffix = \" let\"))\n\n\n\n\nV argumentu labels je možné použít i další funkce. Pro formátování textu je možné využít například funkcí, se kterými jsme se setkali v kapitole věnované stringům (Sekce 18.3):\n\nggplot(dem_countries,\n       aes(x = di_cat, y = freq)) +\n  geom_col() +\n  scale_x_discrete(labels = str_to_upper)"
  },
  {
    "objectID": "vzhled-grafu.html#nadpisy-názvy-a-poznámky",
    "href": "vzhled-grafu.html#nadpisy-názvy-a-poznámky",
    "title": "24  Vzhled grafů",
    "section": "24.5 Nadpisy, názvy a poznámky",
    "text": "24.5 Nadpisy, názvy a poznámky\nVšechny textové popisy grafů je možné ovládat pomocí funkce labs(). Pomocí ní můžeme určit nadpis grafu (title), podnadpis (subtitle), poznámky (caption) a názvy všech použitých dimenzí:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  labs(title = \"Do People Live Longer in Developed Countries?\",\n       subtitle = \"HDI vs Life Expectancy\",\n       caption = \"Data source: Eurostat 2018\",\n       x = \"Human Development Index\",\n       y = \"Life Expectancy at Birth\",\n       color = \"% in risk\\nof poverty\")\n\n\n\n\n\n\n\n\n\n\nText na více řádcích\n\n\n\nPokud chceme aby text v grafu byl zalomený na více řádků, použijeme zvláštní znak \\n, například \"% in risk\\nof poverty\"."
  },
  {
    "objectID": "vzhled-grafu.html#celková-tématika-grafu-themes",
    "href": "vzhled-grafu.html#celková-tématika-grafu-themes",
    "title": "24  Vzhled grafů",
    "section": "24.6 Celková tématika grafu (themes)",
    "text": "24.6 Celková tématika grafu (themes)\nPoslední sekce této kapitoly je věnovaná celkové tématice grafu (anglicky theme). Pomocí funkce theme je možné ovládat všechny aspekty grafu, které nebyli popsány výše. ggplot2 obsahuje sadu předpřipravených tématik, které můžeme aplikovat na každý graf:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPro aplikaci vybrané tématiky stačí připojit její funkci ke grafu:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp)) +\n  geom_point() +\n  theme_linedraw()\n\n\n\n\nKromě předpřipravených tématik je možné také upravovat vzhled grafu manuálně, pomocí funkce theme(). Tato funkce má několik desítek argumentu, které nám umožní kontrolovat i ty nejmenší detaily. My si ukážeme pouze ty nejpoužívanější.\nPrvním aspektem, který budeme chtít často kontrolovat, je pozice legendy. Toho docílíme pomocí argumentu legend.position. Ten může nabývat buď jedné ze čtyř předpřipravených pozic (top, bottom, left a right). Alternativně je možné použít dvojici koordinátů, oba koordináty mohou nabývat hodnot mezi hodnotami 0 a 1. Dvojice c(1,1) umístí legendu pravého horního rohu, c(0,0) do levého horního rohu a c(0.5, 0.5) přímo na střed.\nDále je možné upravovat font textu, a to pomocí argumentu text. Ten přijímá funkci element_text(), pomocí které je možné specifikovat font (family), velikost (size) nebo zda má být text kurzívou/tučně (face). Pokud je naším cílem upravit pouze některý text, je možné využít cílené argumenty jako title nebo axis.text.x)\nBarvuv pozadí grafu je možné ovládat pomocí grafu. Každý graf je rozdělený do dvou částí. Panel je vnitřní oblast grafu, ve které se nachází geomy, zatímco plot je vnější oblast obsahující popisky a legendu. Vlastnosti obou se dají upravovat nezávisle na sobě pomocí argumentů panel.backround a plot.backround. Pokud náš graf obsahuje legendu, můžeme její vzhled upravit obdobně pomocí argumentu legend.backround.\nNávodné čáry grafu kontroluje skupina argumentů panel.grid. Čáry se rozlišují na primární (panel.grid.major) a sekundární (panel.grid.minor). Upravovat také můžeme pouze návodné čáry pro specifickou osu pomocí panel.grid.major.x a panel.grid.major.x (resp. panel.grid.major.y a panel.grid.minor.y). Vzhled čar je možné upravit pomocí funkce element_line(). Pro odebrání čáry, nebo jakéhokoliv jiného elementu grafu, je možné využít funkce element_blank().\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  theme(legend.position = c(0.9, 0.3),\n        text = element_text(family = \"Calibri\", size = 12),\n        panel.background = element_rect(fill = \"#F5DDB1\"),\n        plot.background = element_rect(fill = \"#F5CE87\"),\n        legend.background = element_rect(fill = \"#F5CE87\"),\n        panel.grid.major = element_line(linetype = \"dashed\"),\n        panel.grid.minor = element_blank())\n\n\n\n\n\n\n\n\n\n\nUpravování výchozích tématik\n\n\n\nPokud chceme upravit jednu z výchozích tématik, například theme_linedraw(), použijeme obě funkce za sebou:\n\nggplot(countries,\n       aes(x = hdi, y = life_exp, color = poverty_risk)) +\n  geom_point() +\n  theme_linedraw() +\n  theme(legend.position = \"bottom\")"
  },
  {
    "objectID": "pokrocile-grafy.html#polární-koordináty",
    "href": "pokrocile-grafy.html#polární-koordináty",
    "title": "25  Pokročilé grafy",
    "section": "25.1 Polární koordináty",
    "text": "25.1 Polární koordináty\nVětšina grafů využívá karteziánské koordináty - objekty v grafu jsou mapované na horizontální a vertikální osu. Čas od času se ovšem vyplatí využít jiný systém. Jedním z nejpopulárnějších jsou polární koordináty.\nPřestože si to možná neuvědomujeme, každý z nás se již s polárními koordináty setkal. Slouží k vytváření koláčových grafů, které nejsou ničím jiným, než stočenými skládánými sloupcovými grafy. Začněme vytvořením skládaného sloupcového grafu:\n\ncountries %>% \n  count(postsoviet) %>% \n  ggplot(aes(x = 1, y = n, fill = postsoviet)) +\n  geom_col(position = \"stack\")\n\n\n\n\nNyní jen stači použít funkci coord_polar() pro aplikace polárních koordinátů. Argumentem theta určíme, kterou z os “obtočíme” kolem středu grafu:\n\ncountries %>% \n  count(postsoviet) %>% \n  ggplot(aes(x = 1, y = n, fill = postsoviet)) +\n  geom_col(position = \"stack\") +\n  coord_polar(theta = \"y\")\n\n\n\n\nA je to, koláčový graf je hotový! Obdobným způsobem je možné vytvářet i další varianty. Například takzvaný donut chart, tedy koláčový graf s dírou ve středu, vytvoříme jednoduše tak, že necháme prostor mezi začátkem horizontální osy a sloupcem:\n\ncountries %>% \n  count(postsoviet) %>% \n  ggplot(aes(x = 1, y = n, fill = postsoviet)) +\n  geom_col() +\n  scale_x_continuous(limits = c(0, NA)) + \n  coord_polar(theta = \"y\")"
  },
  {
    "objectID": "pokrocile-grafy.html#skládání-geomů",
    "href": "pokrocile-grafy.html#skládání-geomů",
    "title": "25  Pokročilé grafy",
    "section": "25.2 Skládání geomů",
    "text": "25.2 Skládání geomů\nMnoho komplexních grafů je možné vytvořit kombinací několika vrstev geomů. K tomu nám pomůže fakt, že každá vrstva ggplot2 grafů může mít svůj vlastní zdroj dat a své vlastní mapování. Následující graf se nazývá barbell chart a využívá se pro srovnání zpravidla dvou skupin napříč několika proměnnými. Přestože tento graf může na první pohled vypadat komplikovaně, jedná s jen o dvě sady bodů spojené úsečkou.\n\n\n\n\n\nZačněme přípravou dat. Pro každou ze skupin proměnné postsoviet spočítáme průměr proměnných material_dep, poverty_risk a uni_prc. Data převedeme do dlouhého formátu a poté zpět do širšího. Spočítáme rozdil mezi oběma skupinami pro každou z proměnných a nakonec dáme sloupcům lepší názvy:\n\ncountries %>% \n  group_by(postsoviet) %>% \n  summarise(across(.cols = c(material_dep, poverty_risk, uni_prc),\n                   .fns = mean, na.rm = TRUE)) %>% \n  pivot_longer(cols = -postsoviet) %>% \n  pivot_wider(names_from = postsoviet, values_from = value) %>%\n  mutate(diff = yes-no) %>% \n  rename(western = no,\n         postsoviet = yes)\n\n# A tibble: 3 × 4\n  name         western postsoviet    diff\n  <chr>          <dbl>      <dbl>   <dbl>\n1 material_dep   0.137      0.239  0.102 \n2 poverty_risk   0.223      0.264  0.0419\n3 uni_prc        0.320      0.249 -0.0705\n\n\nDruhým krokem je vytvořením grafu obsahujícím úsečku spojujícím obě skupiny. Pro vytvoření úsečky využijeme funkce geom_segment(), které vyžaduje čtyři argumenty: x, xend, y a yend.\n\ncountries %>% \n  group_by(postsoviet) %>% \n  summarise(across(.cols = c(material_dep, poverty_risk, uni_prc),\n                   .fns = mean, na.rm = TRUE)) %>% \n  pivot_longer(cols = -postsoviet) %>% \n  pivot_wider(names_from = postsoviet, values_from = value) %>%\n  mutate(diff = yes-no) %>% \n  rename(western = no,\n         postsoviet = yes) %>% \n  ggplot(aes(y = name)) +\n  geom_segment(aes(x = western, xend= postsoviet, yend = name), size = 4)\n\n\n\n\nV posledním kroce přidáme body na každou stranu úsečky. Protože průměr každé skupiny je samostatné proměnná, budeme muset použít dvě vrstvy geomů. Dále také budeme muset ručně definovat dimenzi barvy, pro správné vytvoření legendy. Nakonec jen upravíme popisky:"
  },
  {
    "objectID": "pokrocile-grafy.html#více-zdrojů-dat",
    "href": "pokrocile-grafy.html#více-zdrojů-dat",
    "title": "25  Pokročilé grafy",
    "section": "25.3 Více zdrojů dat",
    "text": "25.3 Více zdrojů dat\nJeden graf může být vytvořen z několika dataframů. To se může hodit například v situacích, kdy chceme vytvořit graf obsahující facety zvýrazňující určitou skupinu dat:\n\n\n\n\n\nGraf výše využívá faktu, že facety recyklují všechna pozorovaní, které nepatří do jedné konkrétní facety. Začneme tím, že vytvoříme nový dataframe countries2, který je téměř stejný jako countries, ale neobsahuje proměnnou di_cat (a rovnou se zbavíme chybějících hodnot):\n\ncountries2 <- countries %>% \n  filter(!is.na(di_cat)) %>% \n  select(-di_cat)\n\nPoté vytvoříme bodový graf pro proměnné hdi a life_exp rozdělený do facet podle proměnné di_cat. Zdroj dat ale nespecifikujeme uvnitř funkce ggplot(), ale až ve funkci geom_point(). Jako zdroj dat použijeme countries2. Protože tento dataframe neobsahuje facetovou proměnnou, budou všechny body zobrazeny ve všech facetech:\n\ncountries %>% \n  filter(!is.na(di_cat)) %>% \nggplot(aes(x = hdi, y = life_exp)) +\n  geom_point(data = countries2, alpha = 0.1) +\n  facet_wrap(~di_cat)\n\n\n\n\nNyní přidáme druhou vrstvu bodů, tentokrát založenou na dataframu countries. Tento dataframe již facetovou proměnnou obsahuje, takže body budou zobrazeny jen pro relevantní facetu. Také rovnou skryjeme nepotřebnou legendu:\n\ncountries %>% \n  filter(!is.na(di_cat)) %>% \nggplot(aes(x = hdi, y = life_exp)) +\n  geom_point(data = countries2, alpha = 0.1) +\n  facet_wrap(~di_cat) +\n    geom_point(aes(color = di_cat), show.legend = FALSE)"
  },
  {
    "objectID": "export-grafu.html#export-pomocí-ggsave",
    "href": "export-grafu.html#export-pomocí-ggsave",
    "title": "26  Export grafů",
    "section": "26.1 Export pomocí ggsave()",
    "text": "26.1 Export pomocí ggsave()\nGrafy vytvořené pomocí balíčku ggplot2 je možné uložit pomocí funkce ggsave(). Hlavními argumenty této funkce jsou plot a filename. Pomocí prvního z argumentů určíme, jaký graf chceme exportovat, pomocí druhého název souboru (včetně koncovky). Pokud bychom chtěli uložit graf do jiné složky, než je náš pracovní adresář, využijeme argument path. Dále je možné určit rozměry grafu, pomocí argumentů width a height. Jednotky, ve kterých jsou rozměry grafu definovány, upravujeme pomocí argumentu unit. Na výběr máme centimetry (\"cm\"), milimetry (\"mm\"), palce (\"in\") a pixely (\"px\"). Formát exportovaného obrázku je možné nastavit pomocí device, na výběr máme jak formáty rasterové grafiky (např. png a jpeg), tak vektorové (svg nebo wmf). V případě, že exportujeme graf jako rasterový obrázek, je nutné ještě zvolit vhodné rozlišení, čehož docílíme pomocí argumentu dpi. “Dots per Inch” je (dnes možná lehce archaická) míra, udávající počet kapek inkoust na jeden palce při tisku obrázku. Pro tisk na papír rozměru A4 se zpravidla využívá dpi = 300, pro obrazovky s vysokým rozlišením (retina) poté dpi = 600.\nNásledující příkaz uloží graf hdi_life_plot jako soubor hdi_life_plot.png do složky plots. Graf bude exportován v png formátu, s rozměry 14x10 centimetrů. Protože plánujeme graf vložit do textového dokumentu, nastavíme rozlišení na 300 DPI.\n\nggsave(plot = hdi_life_plot,\n       filename = \"hdi_life_plot.png\",\n       path = \"plots\",\n       device = \"png\",\n       units = \"cm\",\n       width = 14,\n       height = 10,\n       dpi = 300)"
  },
  {
    "objectID": "export-grafu.html#rasterová-versus-vektorová-grafika",
    "href": "export-grafu.html#rasterová-versus-vektorová-grafika",
    "title": "26  Export grafů",
    "section": "26.2 Rasterová versus vektorová grafika",
    "text": "26.2 Rasterová versus vektorová grafika\nJedním z důležitých rozhodnotí při exportu grafů je volba formátu, ve kterém budou uloženy. Obecně máme dvě volby: rasterové a vektorové obrázky.\nRasterové obrázky jsou složeny z velkého množství malých čtverečků, které dohromady skládají celkový obraz. Jedná se o typ obrázku, který používá například fotoaparát vašeho mbilního telefonu. Výhodou rasterové grafiky je schopnost uchovávat komplexní obrázky v malých souborech. Naopak nevýhodou je, že rozlišení i rozměry rasterových obrázku jsou pevně dané. Pokud bychom rasterový obrázek příliš přiblížili, dojde ke ztrátě detailu. Změna rozměrů zase obrázek může zdeformovat.\nVektorové obrázky jsou souborem matematických funkcí, které vykreslují celkový obraz. S vektorou grafikou se setkáte nejčastěji v profesionálním grafickém softwaru, ať už v kontextu grafického designu nebo tisku. Výhodou vektorové grafiky je, že možné dynamicky upravovat rozměry grafu. Obrázky je také možné upravovat i po jejich exportu a budou také vždy perfektně ostré, protože jejich rozlišení je vypočítáváno dynamicky. Nevýhodou je relativně velké množství úložného prostoru, které vyžadují.\nV praxi se nejčastěji setkáte s rasterovými obrázky, pokud budete vytvářet grafy vlastní potřebu (např. do školní práce nebo malého reportu). Naopak pokud spolupracujete s grafikem, jehož prací je vypiplat vaše výstupy k dokonalosti, exportem grafů do vektorové grafiky dotyčnému usnadníte mnoho práce."
  },
  {
    "objectID": "vlastni-funkce.html#počet-chybějících-hodnot-v-proměnné",
    "href": "vlastni-funkce.html#počet-chybějících-hodnot-v-proměnné",
    "title": "27  Vlastní funkce",
    "section": "27.1 Počet chybějících hodnot v proměnné",
    "text": "27.1 Počet chybějících hodnot v proměnné\nJednou z častých operací, kterou v rámci analýzy budeme provádět, je počítat množství chybějících hodnot v proměnné. Poněkud překvapivě, R neobsahuje funkci, která by pro nás chybějící hodnoty spočítala. Musíme proto využít kombinace funkcí is.na() a sum(). Například pro spočítáná chybějících hodnot u proměnné gdp:\n\nsum(is.na(countries$gdp))\n\n[1] 3\n\n\nPro pohodlnost si vytvoříme vlastní funkci jménem count_na(). Pro začátek bude mít tato funkce jeden argument, a to proměnnou, pro které chceme počet chybějících hodnot spočítat:\n\ncount_na <- function(x) {\n  na_count <- sum(is.na(x))\n  \n  return(na_count)\n}\n\nÚtroby této funkce vypadají podobně jako předchozí kód, jen název proměnné je nahrazen generickým argumentem x. Výsledek je uložený do objektu na_count (existujícím pouze uvnitř této funkce). Spočítanou hodnotu poté exportujeme z naší funkce pomocí return(). Takto vytvořenou funkci můžeme využívat tak, jak jsme zvyklí:\n\ncountries %>% \n  summarise(across(.cols = everything(),\n                   .fns  = count_na)) %>% \n  pivot_longer(cols = everything(),\n               values_to = \"missings_count\")\n\n# A tibble: 17 × 2\n   name            missings_count\n   <chr>                    <int>\n 1 country                      0\n 2 code                         0\n 3 gdp                          3\n 4 population                   1\n 5 area                         0\n 6 eu_member                    0\n 7 postsoviet                   0\n 8 life_exp                     1\n 9 uni_prc                      3\n10 poverty_risk                 5\n11 material_dep                 5\n12 hdi                          0\n13 foundation_date              0\n14 maj_belief                   0\n15 dem_index                    1\n16 di_cat                       1\n17 hd_title_name                0\n\n\nNaše funkce spočítá absolutní frekvenci chybějících hodnot v proměnné. Co kdybychom ale chtěli relativní frekvenci, tedy podíl chybějících hodnot z celkového množství pozorování? Toho docílíme tak, že naši funkci rozšíříme o další argument, relative. Pokud bude hodnota tohoto argumentu TRUE, bude počet chybějících hodnot vydělen počtem všech hodnot v proměnné.\n\ncount_na <- function(x, relative = FALSE) {\n  na_count <- sum(is.na(x))\n  \n  if(relative){\n    na_count <- na_count / length(x)\n  }\n  \n  return(na_count)\n}\n\nVšimněme si, že oproti předchozí verzi, jsme v naší funkci udělali několik změn. Zaprvé jsme přidali argument relative, jehož výchozí hodnotu jsme nastavili na FALSE (ve výchozím nastavení tedy funkce počítá absolutní počet chybějících hodnot). Dále jsme přidali blok začínající funkcí if(). Tato funkce zkontroluje, jestli je hodnota argumentu relative rovná TRUE a pokud ano, vydělí počet chybějících hodnot celkovou délkou proměnné x. Funkci používáme tak, jak jsme zvyklí:\n\ncountries %>% \n  summarise(across(.cols = everything(),\n                   .fns  = count_na, relative = TRUE)) %>% \n  pivot_longer(cols = everything(),\n               values_to = \"missings_count\")\n\n# A tibble: 17 × 2\n   name            missings_count\n   <chr>                    <dbl>\n 1 country                 0     \n 2 code                    0     \n 3 gdp                     0.0789\n 4 population              0.0263\n 5 area                    0     \n 6 eu_member               0     \n 7 postsoviet              0     \n 8 life_exp                0.0263\n 9 uni_prc                 0.0789\n10 poverty_risk            0.132 \n11 material_dep            0.132 \n12 hdi                     0     \n13 foundation_date         0     \n14 maj_belief              0     \n15 dem_index               0.0263\n16 di_cat                  0.0263\n17 hd_title_name           0"
  },
  {
    "objectID": "vlastni-funkce.html#graf-pro-likertovské-položky",
    "href": "vlastni-funkce.html#graf-pro-likertovské-položky",
    "title": "27  Vlastní funkce",
    "section": "27.2 Graf pro likertovské položky",
    "text": "27.2 Graf pro likertovské položky\nKomplexnějším příkladem vlastní funkce je vytvoření grafu pro baterii likertovských položek. Přestože vytvoření takového grafu je pomocí ggplot2 možné, jde o poměrně zdlouhavý proces. Jako příklad si můžeme ukázat vizualizaci položek týkajících se postojů veřejnosti o válce na Ukrajině. Data pochází z dotazníkového šetření Centra pro průzkum veřejného mínění z března 2022. Data jsou rozdělena do dvou dataframů. První z nich, ukraine, obsahuje odpovědi respondentů a druhý, ukraine_labels, obsahuje zjednodušené znění jednotlivých položek.\n\nukraine <- read_rds(\"data-raw/ukraine.rds\")\nukraine_labels <- read_rds(\"data-raw/ukraine_labels.rds\")\n\nPro vytvoření grafu popisující postoje občanů k různým formám zapojení zemí do války vypadá následovně:\n\nlibrary(RColorBrewer)\nlibrary(scales)\n\nlikert_palette <- c(\"grey70\", brewer.pal(4, \"RdYlGn\"))\n\nukraine %>% \n  select(starts_with(\"PL_5\")) %>% \n  pivot_longer(cols = everything(),\n               names_to = \"item\",\n               values_to = \"response\") %>% \n  left_join(ukraine_labels, by = \"item\") %>% \n  count(label, response) %>% \n  filter(!is.na(response)) %>% \n  group_by(label) %>% \n  mutate(freq = n / sum(n),\n         freq_label = percent(freq, accuracy = 1),\n         positive = sum(freq[response %in% c(\"rozhodně by mělo\", \"spíše by mělo\") ])) %>% \n  ungroup() %>% \n  mutate(label = fct_reorder(label, positive),\n         response = fct_rev(response)) %>% \n  ggplot(aes(x = freq, y = label, label = freq_label, fill = response)) +\n  geom_col() +\n  geom_text(position = position_stack(vjust = 0.5),\n            color = \"white\",\n            size = 3) +\n  scale_x_continuous(labels = percent_format()) +\n  scale_fill_manual(values = likert_palette) +\n  labs(x = element_blank(),\n       y = element_blank(),\n       fill = element_blank(),\n       title = \"Jaké kroky by podle vás mělo podniknout mezinárodní společenství tváří v tvář\\nválce na Ukrajině? Mělo by...\") + \n  theme_minimal() +\n  theme(legend.position = c(0.3, -0.17),\n        panel.grid.major.y = element_blank(),\n        plot.title.position = \"plot\",\n        plot.margin = unit(c(0,0,3.5,0), 'lines')) +\n  guides(fill = guide_legend(label.position = \"bottom\",\n                             keywidth = 5,\n                             reverse = TRUE,\n                             direction = \"horizontal\"))\n\n\n\n\nUf… asi si dokážeme představit, že použít takto monstrózní kus kódu opakovaně je nejen otravné, ale i recept na to něco zkazit. Naštěstí pro nás, většina kódu zůstané při každém použití stejná. Jediné, co se bude měnit jsou 1) použitá data, 2) barevná paleta, 3) odpovědi, podle kterých jsou položky seřazeny, 4) název a 5) dataframe obsahující znění položek. Vytvořme si funkci plot_likert, která tento graf udělá za nás:\n\nplot_likert <- function(data, color_palette, order_by, title, var_labels) {\n data %>% \n  pivot_longer(cols = everything(),\n               names_to = \"item\",\n               values_to = \"response\") %>% \n  left_join(var_labels, by = \"item\") %>% \n  count(label, response) %>% \n  filter(!is.na(response)) %>% \n  group_by(label) %>% \n  mutate(freq = n / sum(n),\n         freq_label = percent(freq, accuracy = 1),\n         positive = sum(freq[response %in% order_by ])) %>% \n  ungroup() %>% \n  mutate(label = fct_reorder(label, positive),\n         response = fct_rev(response)) %>% \n  ggplot(aes(x = freq, y = label, label = freq_label, fill = response)) +\n  geom_col() +\n  geom_text(position = position_stack(vjust = 0.5),\n            color = \"white\",\n            size = 3) +\n  scale_x_continuous(labels = percent_format()) +\n  scale_fill_manual(values = color_palette) +\n  labs(x = element_blank(),\n       y = element_blank(),\n       fill = element_blank(),\n       title = title) + \n  theme_minimal() +\n  theme(legend.position = c(0.3, -0.17),\n        panel.grid.major.y = element_blank(),\n        plot.title.position = \"plot\",\n        plot.margin = unit(c(0,0,3.5,0), 'lines')) +\n  guides(fill = guide_legend(label.position = \"bottom\",\n                             keywidth = 5,\n                             reverse = TRUE,\n                             direction = \"horizontal\")) \n}\n\nDefinice naší funkce vypadá téměř identicky jako původní kód, pět výše zmíněných částí jsme strategicky nahradili argumenty naší funkce. Jakmile je funkce vytvořené, je možné jí aplikovat na data. Kód pro vytvoření grafu se smrknul z třiceti řádků na šest:\n\nukraine %>% \n  select(starts_with(\"PL_5\")) %>% \n  plot_likert(color_palette = likert_palette,\n              order_by = c(\"rozhodně by mělo\", \"spíše by mělo\"),\n              title = \"Jaké kroky by podle vás mělo podniknout mezinárodní společenství tváří v tvář\\nválce na Ukrajině? Mělo by...\",\n              var_labels = ukraine_labels)\n\n\n\n\nNaší funkci můžeme stejně jednoduše aplikovat na druhou baterii v datech, týkající se vnímané hrozby použití atomových zbraní:\n\nlikert_palette2 <- c(\"grey70\", rev(brewer.pal(4, \"RdYlBu\")))\n\nukraine %>% \n  select(starts_with(\"PL_6\")) %>% \n  plot_likert(color_palette = likert_palette2,\n              order_by = c(\"velmi se obává\", \"trochu se obává\"),\n              var_labels = ukraine_labels,\n              title = \"Obáváte se, že Rusko může použít jaderné zbraně…\")\n\n\n\n\nJak je vidět, vytvořením vlastní funkce si můžeme výrazně ulehčit práci, nemluvě o tom, že tím náš kód uděláme čitelnější a robustnější."
  },
  {
    "objectID": "for-loops.html#kdo-je-členem-gangu",
    "href": "for-loops.html#kdo-je-členem-gangu",
    "title": "28  For loops (cykly)",
    "section": "28.1 Kdo je členem gangu?",
    "text": "28.1 Kdo je členem gangu?\nZákladní aplikaci For cyklu si představím na jednoduchém příkladu. Naším cílem bude vyjmenovat jednotlivé členy Scoobyho gangu. Nejdříve si vytvoříme objekt obsahující jména členů:\n\ngang <- c(\"Fred\", \"Velma\", \"Daphne\", \"Shaggy\", \"Scooby\")\n\nBez For cyklů musíme členy vyjmenovat ručně. Využijeme k tomu funkci paste(), pomocí které spojíme jméno člena/ky s větou “is a member!” :\n\npaste(gang[1], \"is a member!\")\n\n[1] \"Fred is a member!\"\n\npaste(gang[2], \"is a member!\")\n\n[1] \"Velma is a member!\"\n\npaste(gang[3], \"is a member!\")\n\n[1] \"Daphne is a member!\"\n\npaste(gang[4], \"is a member!\")\n\n[1] \"Shaggy is a member!\"\n\npaste(gang[5], \"is a member!\")\n\n[1] \"Scooby is a member!\"\n\n\nToto řešení je dost nepraktické, protože opakovaně kopírujeme stejný kód. Přitom jediné, co se ve funkcích výše mění, je pořadí člena. Elegantnější alternativou je již zmiňovaný for cyklus. For cyklus lze v R aplikovat (minimálně) dvěma způsoby.\nPrvním způsobem je explicitní for loop. Explicitní for loop začíná funkcí for(), následovanou složenými závorkami. Argumenty for() funkce mají speciální podobu, v našem případě bude funkce vypadat následovně: for(name in gang). Tímto říkáme, že chceme aplikovat nějakou funkci na každý element (zde zvaný name) objektu gang. Můžeme si přitom zvolit jakkékoliv označení pro jednotlivé elementy, které chceme. Zde používáme name, ale stejně tak bychom mohli použít například for(i in gang) nebo for(pesky_child in gang). Následují složené závorky, definující, jaké funkce se na každý element mají aplikovat. Celý for loop by našem případě vypadal následovně:\n\nfor(name in gang) {\n  print(paste(name, \"is a member!\"))\n}\n\n[1] \"Fred is a member!\"\n[1] \"Velma is a member!\"\n[1] \"Daphne is a member!\"\n[1] \"Shaggy is a member!\"\n[1] \"Scooby is a member!\"\n\n\nJak je vidět, nemusíme již kopírovat funkci paste() pětkrát za sebou. For cyklus se o to postará za nás. Výhodou explicitních for loops je, že se aplikují téměř identicky v každém programovacím jazyce. Pokud se tedy seznámíte s for cykly v R, můžete je jednoduše aplikovat i Pythonu nebo Julii.\nNevýhodou explicitních for cyklů, že jsou relativně květnaté - jejich zápis je delší, než je nezbytně nutné. Alternativou jsou funkce z balíčku purrr, který je součástí Tidyverse. Tyto funkce také aplikují různé druhy cyklů, jejich zápis je ale kompaktnější. Hlavní funkcí je zde map(), která má dva argumenty. Prvním argumentem je .x, objekt přes jehož elementy chceme iterovat. Druhým argumentem jsou funkce, které chceme aplikovat:\n\nmap(.x = gang, ~paste(.x, \"is a member!\"))\n\n[[1]]\n[1] \"Fred is a member!\"\n\n[[2]]\n[1] \"Velma is a member!\"\n\n[[3]]\n[1] \"Daphne is a member!\"\n\n[[4]]\n[1] \"Shaggy is a member!\"\n\n[[5]]\n[1] \"Scooby is a member!\"\n\n\nJak je vidět, funkce map() zabírá méně prostoru, než explicitní for loop (a má další výhody, které zmínímě za chvíli). Výsledkem této funkce je objekt typu list. Protože ale víme, že výsledkem naší funkce je věta, můžeme využít funkci map_chr(), jejímž výsledkem je character vektor:\n\nmap_chr(.x = gang, ~paste(.x, \"is a member!\"))\n\n[1] \"Fred is a member!\"   \"Velma is a member!\"  \"Daphne is a member!\"\n[4] \"Shaggy is a member!\" \"Scooby is a member!\"\n\n\nObdobně bychom mohli využít funkce map_dbl() pokud je výsledkem desetinné číslo, map_int() pro celé číslo nebo map_lgl() pokud je výsledkem logický vektor."
  },
  {
    "objectID": "for-loops.html#průměr-každé-numerické-proměnné",
    "href": "for-loops.html#průměr-každé-numerické-proměnné",
    "title": "28  For loops (cykly)",
    "section": "28.2 Průměr každé numerické proměnné",
    "text": "28.2 Průměr každé numerické proměnné\nVyzkoušejme si nyní o něco praktičtější příklad. Naším cílem bude spočítat průměr každé numerické proměnné v datasetu countries. Začněme tím, že si vyfiltrujeme pouze numerické proměnné.\n\ncountries_numeric <- select(countries, where(is.numeric))\n\nNejdříve spočítme průměry proměnných pomocí explicitního for cyklu. Prvním krokem je vytvořením prázdného vektoru, do kterého uložíme výsledky. Toho docílíme pomocí funkce vector(). Tento krok není nezbytně nutný, jedná se ale o dobrou praxi, protože urychlí výpočet. Poté definujeme for loop samotný. Nejdřív musíme získat pořadí jednotlivých proměnných v dataframu, a to pomocí funkce seq_along(). Ta vytvoří vektor čísel od 1 po hodnotu rovnou počtu elementů v objektu, přes iterujeme. Náš dataframe obsahuje devět proměnných, seq_along(countries_numeric) tedy vytvoří řadu celých čísel od 1 do 9. Uvnitř for cyklu spočítáme průměr i-té proměnné a výsledek uložíme jako i-tý element předpřipraveného objektu countries_means:\n\ncountries_means <- vector(\"numeric\", length = ncol(countries_numeric))\n\nfor (i in seq_along(countries_numeric)) {\n  countries_means[i] <- mean(countries_numeric[[i]], na.rm = TRUE)\n}\n\ncountries_means\n\n[1] 4.846008e+05 1.675474e+07 1.560186e+05 7.957838e+01 2.914857e-01\n[6] 2.403030e-01 1.798788e-01 8.739474e-01 7.639189e+00\n\n\nVýsledkem je devět průměrů pro devět proměnných. Zde začínáme vidět, že explicitní for cykly mohou být poněkud krkolomné. Je třeba předvytvořit vektor pro výsledky a musíme pracovat s pořadím proměnných. Vyzkoušejme si stejný úkol pomocí funkcí funkcí z balíčku purrr.\nNarozdíl od explicitního for cyklu není třeba předvytvářet vektor pro výsledky, map() a příbuzné funkce to za nás udělají automaticky. také není třeba řešit pořadí proměnných pomocí seq_along(). Stačí nám tedy aplikovat funkci map_dbl() (protože výsledkem bude desetinné číslo) následovně:\n\nmap_dbl(.x = countries_numeric, ~mean(.x, na.rm = TRUE))\n\n         gdp   population         area     life_exp      uni_prc poverty_risk \n4.846008e+05 1.675474e+07 1.560186e+05 7.957838e+01 2.914857e-01 2.403030e-01 \nmaterial_dep          hdi    dem_index \n1.798788e-01 8.739474e-01 7.639189e+00 \n\n\nJak vidíme, tato funkce je mnohem kompaktnější a navíc zachovává názvy původních proměnných. Jinak jsou výsledky identické."
  },
  {
    "objectID": "for-loops.html#histogram-pro-každou-numerickou-proměnnou",
    "href": "for-loops.html#histogram-pro-každou-numerickou-proměnnou",
    "title": "28  For loops (cykly)",
    "section": "28.3 Histogram pro každou numerickou proměnnou",
    "text": "28.3 Histogram pro každou numerickou proměnnou\nNaším dalším cílem bude vytvoření histogramu pro každou proměnnou datasetu countries_numeric. Graf pro jednu proměnnou můžeme vytvořit tak, jak jsme si ukázali v předchozích kapitolách:\n\ncountries_numeric %>% \n  ggplot(aes(x = hdi)) +\n  geom_histogram(bins = 15, fill = \"dodgerblue\", color = \"white\") +\n  theme_minimal()\n\n\n\n\nCo kdychom chtěli efektivně vytvořit tento graf pro všechny proměnné. S využitím funkce map() je to jednoduché. Jedinou změnou oproti předchozím příkladům bude využití složených závorek, které nám umožní aplikovat více funkcí najednou uvnitř jednoho for cyklu:\n\ncountries_histograms <- map(.x = countries_numeric,\n                            ~{countries_numeric %>% \n                              ggplot(aes(x = .x)) +\n                              geom_histogram(bins = 15, fill = \"dodgerblue\", color = \"white\") +\n                              theme_minimal()\n                                })\n\nKód pro vytvoření grafu je téměř identický, pouze název proměnné jsme nahradili generickým argumentem .x. Výsledkem je list, obsahující devět grafů. Naše grafy ovšem postrádají nadpis, který by identifikoval, kterou proměnnou reprezentují. Naším dalším cílem tedy bude přidání popisků obsahující název proměnné. Pro jeden konkrétní graf bychom graf s popiskem vytvořili následovně:\n\ncountries_numeric %>% \n  ggplot(aes(x = hdi)) +\n  geom_histogram(bins = 15, fill = \"dodgerblue\", color = \"white\") +\n  theme_minimal() +\n  labs(title = \"Histogram for Human Development Index\")\n\n\n\n\nPro vytvoření podobného grafu bude třebat iterovat přes dvě objekty. Prvním objektem je proměnná, pro kterou chceme histogram vytvořit, druhým je vektor názvů, které chceme v grafech použít. K tomu využijeme funkci map2(). Ta funguje velmi podobně, jako nám již známá funkce map(), ale kromě argumentu .x má i druhý .y, čímž nám umožňuje dosadit do cyklu dva různé objekty. Pro vytvoření grafů s popisky pro každou z proměnných nejdříve vytvoříme vektor obsahující názvy všech proměnných a poté aplikujeme funkci map2():\n\ncountries_names <- c(\"Gross Domestic Product\",\n                     \"Population\",\n                     \"Area\",\n                     \"Life Expectancy\",\n                     \"Proportion of People with University Degree\",\n                     \"Proportion of People at the risk of Poverty\",\n                     \"Proportion of Materialy Deprived\",\n                     \"Human Development Index\",\n                     \"Democratic Index\")\n\ncountries_histograms <- map2(.x = countries_numeric,\n                             .y = countries_names,\n                             ~{countries_numeric %>% \n                               ggplot(aes(x = .x)) +\n                               geom_histogram(bins = 15, fill = \"dodgerblue\", color = \"white\") +\n                               theme_minimal() +\n                               labs(title = paste(\"Histogram for\", .y))})\n\nA je to! Graf pro jednotlivé proměnné můžeme zobrazit jejich zavoláním:\n\ncountries_histograms$dem_index\n\n\n\n\n\n\n\n\n\n\nIterace více než dvou objektů\n\n\n\nFunkce map2() nám umožňuje iterativně aplikovat funkce na dva objekty najednou. Co kdybychom ale chtěli iterovat přes tři, čtyři nebo více objektů? Právě k tomu slouží funkce pmap(). Funkce pmap() funguje trochu odlišně oproti klasickému map(). Prvním argumentem je list objektů, přes které chceme iterovat. Každému z těchto objektů je přiděleno kódové označení - první objekt dostane označní ..1, druhý ..2, třetí ..3 a tak dále. Druhým argumentem jsou poté funkce, které chceme aplikovat. Pokud bychom chtěli předchozí úkol vyřešit pomocí pmap() místo map2():\n\ncountries_histograms <- pmap(list(countries_numeric,  #..1\n                                  countries_names),   #..2 \n                             ~{countries_numeric %>% \n                               ggplot(aes(x = ..1)) +\n                               geom_histogram(bins = 15,\n                                              fill = \"dodgerblue\",\n                                              color = \"white\") +\n                               theme_minimal() +\n                               labs(title = paste(\"Histogram for\", ..2))})"
  },
  {
    "objectID": "for-loops.html#boostraping",
    "href": "for-loops.html#boostraping",
    "title": "28  For loops (cykly)",
    "section": "28.4 Boostraping",
    "text": "28.4 Boostraping\nPosledním příkladem využití for cyklů, který si zde ukážeme, je boostraping. Většina čtenářů pravděpodobně ví, že výzkumníci většinou nemají k dispozici data o celé populaci, kterou studují. Místo toho se musíme spokojit pouze s jejím vzorkem. Žádný vzorek ale svým složením nekopíruje dokonale populaci, ze které byl získaný. Tyto odchylky ve složení vzorku vedou k odchylkám v našich výsledcích. Učebnicovým příkladem jsou předvolební výzkumy - pokud ve vzorku voličů podporuje určitou politickou stranu například 5 procent respondentů, reálná podpora strany v populaci je zpravidla něco mezi 3 a 8 procenty. Tyto odchylky od skutečné hodnoty (takzvaná výběrová chyba) jsou náhodné a velká část statistiky je věnována jejímu vyčíslení. Protože zde nechceme příliš zabíhat do statistické teorie, doporučjeme zájemcům o více informací učebnici Learning Statistics with R od Danielle Navarro. My si zde ukážeme jeden ze způsobů, jak tuto náhodnou výběrovou chybu vyčíslit, a to boostrapping.\nMetoda bootstrappingu je založená na vytváření nových vzorků pomocí opakovaného náhodného vytahování pozorování z našich původních dat. Pozorování jsou vytahována s opakováním, jedno pozorování se tedy může do nového vzorku může dostat více než jednou. Tímto způsobem můžeme za určitých podmínek zodpovědět otázku “Jak by se naše výsledky lišily, kdybychom nasbírali trochu odlišná data?”. R nabízí několik balíčku pro aplikaci boostrappingu, jako jsou boot, rsample, coin nebo infer. Jednoduchý boostrapping je ale možné aplikovat pomocí for cyklů.\nBoostrapping probíhá ve dvou krocích. V prvním kroku vytvoříme boostrapový vzorek pomocí náhodného výběru s opakováním z původních dat (je přitom nezbytné, aby nový vzorek měl stejný počet pozorování, jako ten původní). Poté spočítáme statistiku, pro kterou chceme vyčíslit náhodnou výběrovou chybu (například průměr). Tyto dva kroky mnohokrát opakujeme, čímž dostaneme vektor statistik, spočítaný na vzorcích s trochu odlišným složením. Tyto hodnoty představují odhad výběrové distribuce výběrové statistiky.\nJako praktický příklad zkusme vyčíslit výběrovou chybu průměru proměnné hdi v datasetu countries. Začněme aplikací funkce map_dbl(). To použijeme, protože víme, že jednotlivé průměry jsou čísla a výsledkem tedy bude numerický vektor. Prvním argumentem není žádný konkrétní objekt, místo toho se jedná o vektor celých čísel od 1 po hodnotu určující počet bootstrapových vzorků, které chceme vytvořit. My budeme chtít vytvořit 10 000 vzorků, prvním argumentem tedy bude 1:10000. Druhým argumentem je výpočet bootstrapové statistiky samotné. K tomu nejdříve využijeme funkce sample(), pomocí které vytvoříme boostrapový vzorek. Dáme si přitom pozor nato, abychom nastavili argument replace = TRUE, čímž zajistíme, že výběr probíhá s opakováním (jinak bychom skončili pokaždé se stejným vzorkem). Poté už jen stačí spočítat požadovanou statistiku, v našem případě průměr. Celá funkce funkce provádí následjící - pro každý krok od prvního po desetitisící vytvoř nový bootstrapový vzorek a spočítej jeho průměr. Výsledek uložíme do objektu hdi_bootstraps:\n\nhdi_bootstraps <- map_dbl(1:10000,\n                          ~{\n                            sample <- sample(countries$hdi, replace = TRUE)\n                            mean(sample)\n                            })\n\nVýsledný vektor 10 000 průměrů představuje odhad výběrové distribuce průměrů proměnné hdi. Můžeme jí graficky zobrazit:\n\nqplot(hdi_bootstraps)\n\n\n\n\nMůžeme spočítat standardní odchylku výběrových průměrů (tedy standardní chybu):\n\nsd(hdi_bootstraps)\n\n[1] 0.008656185\n\n\nA nakonec můžeme spočítat 95% intervalový odhad průměru hdi:\n\nquantile(hdi_bootstraps, probs = c(0.025, 0.975))\n\n     2.5%     97.5% \n0.8568421 0.8907895 \n\n\nA je to! Boostrapping představuje jednoduchý způsob vyčíslení náhodné výběrové chyby, a to zejména pokud pracujeme s většími vzorky s jednoduchou strukturou. Čtenáři by ovšem měli mít na paměti dvě věci. Zaprvé, bootstrapované hodnoty představují pouze odhad výběrové distribuce - čím více simulací, tím přesnější odhad bude. Zadruhé, boostrapping je stejně jako všechny ostatní statistické nástroje založený na sadě předpokladů, které zaručují jeho správnou funkci. Pokud je některý z těchto předpokladů výrazně porušený, naše výsledky se stanou velmi nepřesnými. Čtenáři by si měli důkladně nastudovat potřebnou teorii, než aplikují bootstrapping v praxi.\n\n\n\n\n\n\nR rozumí vědecké notaci\n\n\n\nProtože R rozpoznává vědeckou notaci, je možné nahradit 10000 výrazem 1e4. Výsledná funkce tedy může vypadat následovně:\n\nhdi_bootstraps <- map_dbl(1:1e4,\n                          ~{\n                            sample <- sample(countries$hdi, replace = TRUE)\n                            mean(sample)\n                            })"
  },
  {
    "objectID": "co-dal.html#statistika",
    "href": "co-dal.html#statistika",
    "title": "29  Co dál?",
    "section": "29.1 Statistika",
    "text": "29.1 Statistika\nCesta, která se přirozeně nabízí, je dále se vzdělávat v oblasti statistiky a statistického modelování. Zájemcům o studium statistiky doporučujeme začít knihou Learning Statistics with R od Danielle Navarro, která vás přátelským způsobem provede úvodem do statistické teorie. Navázat na ní můžete s Regression and Other Stories od Andrewa Gelmana, Jennifer Hill a Aki Vehtariho, knihou která poskytne cenné rady týkající se statistického modelování jak začátečníkům, tak pokročilým. Z trochu jiného soudku je Tidy Modelling with R od Maxe Kuhna a Julie Silge, text zaměřený na prediktivní modelování a “machine learning”."
  },
  {
    "objectID": "co-dal.html#vizualizace-dat",
    "href": "co-dal.html#vizualizace-dat",
    "title": "29  Co dál?",
    "section": "29.2 Vizualizace dat",
    "text": "29.2 Vizualizace dat\nTi z vás, kteří našli svůj zájem ve vizualizaci dat jistě ocení knihu Fundamentals of Data Visualization od Clause Wilkea. Ta vás provede teorií a užitečnámi tipy pro vytváření hezky vypadajících a zároveň efektivních grafů. Naleznete v ní vše od návodů pro vizualizaci různých druhů proměnných až po tipy pro vytváření barevných palet. Pro hlubší pochopení fungování balíčku ggplo2 a gramatiky grafů doporučujeme ggplot2: elegant graphics for data analysis od Hadleyho Wickhama, Danielle Navarro, and Thomase Lin Pedersena."
  },
  {
    "objectID": "co-dal.html#oragnizace-práce",
    "href": "co-dal.html#oragnizace-práce",
    "title": "29  Co dál?",
    "section": "29.3 Oragnizace práce",
    "text": "29.3 Oragnizace práce\nPoslední a neméně důležitou oblastí je organizace práce. Ti z vás, kteří mají zkušenosti z prací v týmech a na dlouhodobých projektech jistě chápou jak nezbytné je mít dobře nastavené systémy pro sdílení a zálohování dat, analýz a výsledků. Užitečné tipy pro toto vše nabízí The Plain Person's Guide to Plain Text Social Science od Keirana Healyho. Pro moderního analytika je nezbytný především verzovací program Git, se kterým vás seznámí Happy Git and GitHub for the useR od Jennifer Bryan."
  },
  {
    "objectID": "co-dal.html#na-vše-ostatní-je-tu-big-book-of-r",
    "href": "co-dal.html#na-vše-ostatní-je-tu-big-book-of-r",
    "title": "29  Co dál?",
    "section": "29.4 Na vše ostatní je tu Big Book of R",
    "text": "29.4 Na vše ostatní je tu Big Book of R\nPokud vás žádné z předchozích témat nezaujalo, nemusíte smutnit. Big Book of R je ultimátní kniha knih spravovaná Oscarem Baruffem. V ní naleznete odkazy na zdroje týkající se nepřeberného množství témat. Na své si přijdou všichni, od fanoušku analýzy sociální sítí po finanční analytiky a datové žurnalisty. Rozhodně doporučujeme si najít klidnou půl hodinu a knihu si projít.\nA to je vše! Doufáme, že se vám naše kniha líbila a přejeme mnoho zdaru s analýzami. :-)"
  }
]