# Import a export dat

Předtím, než můžeme tvořit, je nutné dostat data do R. Tato kapitola bude věnovaná importu a exportu dat v nejběžnějších formátech, k čemuž využijeme balíčky `readr`, `haven`, `readxl` a `writexl`. První z nich je součástí tzv. core Tidyverse. To znamená, že se načte vždy při provedení `r library(tidyverse)`, což je povinná součást prakticky každého skriptu, pokud vycházíte z této učebnice. Balíčky `haven` a `readxl` jsou také součástí Tydiverse, ale je potřeba je načíst samostatně. Balíček `writexl` je v tuhle chvíli asi nejlepší nástroj na zapisování do sešitů formátu .xlsx, což ocení především při spolupráci s lidmi, kteří sami nepracují v R.

## Pracovní adresář

Předtím, než se pustíme do importu dat samotného, je dobré se seznámit s konceptem pracovního adresáře (*working directory*). Pracovní adresář je výchozí složka na vašem počítači, do které se bude R v rámci daného projektu dívat. Cestu k vašemu současnému pracovnímu adresáři zjistíte pomocí funkce `getwd` (*get working directory*):

```{r getwd}
getwd()
```

Pokud provedete funkci výše, dostanete pravděpodobně něco jako `"C:/Users/.../uvod-do-r-kniha"`, kde poslední v řetezci je název složky, ve které je umístěný aktuální projekt. Pokud bychom po R chtěli importovat nějaký datový soubor, R ho bude hledat v této složce. Stejně tak, pokud bychom exportovali například vytvořený graf, bude deafaultně uložen do této složky. Na koncept pracovního adresáře je dobré si zvyknout rychle, protože mnoho problémů, které začínající uživatelé mají během importu dat, je způsobeno buď odkazováním na špatnou složku nebo neznalostí jejich pracovního adresáře.

::: callout-tip
## Ať se o to postará Rstudio

Jednou z velkých předností Rstudio projektů (viz @sec-rstudio-projects ) je automatické nastavení pracovního adresáře do kmenové složky vašeho projektu při startu. To pomáhá zajistit, že pracovní adresář bude vždy poblíž vašich dat, což výrazně ulehčuje jejich import.
:::

Výchozí pracovní adresář (mimo Rstudio projekt) je možné nastavit v *Tools* -\> *Global Options* -\> *General*. Pracovní adresář je také možné nastavit ručně pomocí funkce `setwd()`, tuto možnost ale silně nedoporučujeme. Problém spočívá v tom, že jakákoliv adresa na vašem počítači je platná jen pro váš počítač. Pokud byste složku s vaším projektem přesunuli na jiné místo nebo poslali kolegovi, bylo by nutné měnit všechny pracovní adresáře ručně. Mnohem lepší je spoléhat na automatické nastavení pomocí Rstudio projektů a sdílet celé projekty.

## Import dat

### Comma seperated values

Jedním z nejčastějších a hlavně nejuniverzálnějších typů datových souborů, se kterými se pravděpodobně setkáte, jsou takzvané *comma separated values (CSV)* soubory. Ty se dají poznat jednoduše podle koncovky `.csv`. Data tohoto typu můžeme naimportovat do R pomocí funkce `read_csv()` z balíčku `readr`.

Možnosti, jak říct R, kde má soubor hledat, jsou dvě. Tou preferovanou je využít relativní cesty (*relative path*). Relativní cesta začíná ve vašem pracovní adresáři a můžeme jít specifikovat následovně:

```{r import-relative}
#| eval: false
library(tidyverse) # nezapomeňte na nahrání balíčku!

countries <- read_csv("data-raw/countries.csv")
```

Tento příkaz říká R, aby se v pracovním adresáři podívalo do složky `data-raw` a v ní hledalo soubor `countries.csv`. Nalezený soubor potom naimportuje jako dataframe a pojmenuje `countries`.

Alternativně je možné specifikovat úplnou cestu k souboru (*full path*):

```{r import-full}
#| eval: false
countries <- read_csv("/Users/ales/Documents/phd/teaching/uvod-do-r-kniha/data-raw/countries.csv")
```

Oproti předchozímu příkladu je plná cesta mnohem delší a nebude fungovat u jiného uživatele (ten si ji bude muset přepsat podle toho, kam přesně si data uloží). Silně proto doporučujeme plné cesty *nevyužívat*, a to ze stejného důvodu, ze kterého byste neměli ručně nastavovat pracovní adresáře.

::: callout-note
## read_csv versus read.csv

Pro import dat do R není nezbytně nutné využívat balíček `readr`, potažmo `tidyverse`. Základní instalace R obsahuje funkci `read.csv()`, pomocí které byste mohli data importovat stejným způsobem. My ale preferujeme `read_csv()`, protože je rychlejší a dává nám větší kontrolu nad tím, jak jsou data importována.
:::

Data lze stejným způsobem stahovat i z internetu:

```{r import-net}
#| eval: false
countries <- read_csv("https://raw.githubusercontent.com/Sociology-FA-CU/Uvod_do_analyzy_dat_v_R/master/data/countries.csv")
```

Bohužel, ne všechna data uložená ve formátu `.csv` jsou opravdu hodnoty oddělené čárkami. Přestože tyto atypické formáty mohou vzniknout více způsoby, primárním zdrojem problémů je většinou Microsoft Excel. Ten je distribuován v řadě regionálních verzí, z nichž každá se chová trochu jinak. Konkrétně verze pro střední Evropu využívá pro oddělování hodnot středníky (`;`), protože středoevropské země historicky využívají čárku pro oddělení desetinných míst (anglofonní svět využívá desetinnou tečku, kterou je také pro oddělení desetinných míst potřeba využívat v R). To vede k řadě otravných problému při importu a exportu dat, zvláště v mezinárodních týmech.

V případě, že se setkáte s datovým souborem, který nepoužívá klasické oddělovače, máte dvě možnosti. Tou první je pomocí argumentů funkce `read_csv()` ručně upravit, které hodnoty mají být viděni jako oddělovače sloupců a které jako oddělovače desetinných míst. Například:

```{r import-csv-locale}
#| eval: false
countries <- read_csv("data-raw/countries.csv",
                      locale = locale(grouping_mark = ";",
                                      decimal_mark = ","))
```

Protože problémy s importem dat produkovaných ve střední Evropě jsou extrémně časté, balíček `readr` obsahuje funkci `read_csv2()`, která plní stejný účel jako kód výše. Druhou možností je tedy ulehčit si psaní a využít ji:

```{r import-csv-locale2}
#| eval: false
countries <- read_csv2("data-raw/countries.csv")
```

Pokud máte data ve formátu `.csv` a nejste si jistí, co je oddělovač, je nejrychlejší vyzkoušet `read_csv()` a `read_csv2()` a podívat se, ve kterém případě se data načtou správně.

::: callout-warning
## Peklo jménem locale encoding

Kromě problému s oddělovači se při práci s neanglickým textem setkáte pravděpodobně ještě s jedním problémem: nesprávným zobrazením českých znaků (resp. znaků, které nejsou obsaženy v anglosaské abecedě). Uchovávání textu ve výpočetní technice je komplexním problémem, pro který existuje velké množství standardů. Autoři většiny operačních systémů, včetně Linuxu a MacOS, se dnes již shodli na využívání univerzálního standardu zvaného UTF-8. Microsoft a jeho Windows ovšem historicky využíval několik desítek standardů v závislosti na regionální verzi operačního systému. Dobrou zprávou je, že Microsoft konečně přijal univerzální kódování URF-8. Stále se však vytváří (nebo historicky koluje) mnoho dokumentů v jiném kódování, což vede k problémům při analýze dat, jelikož data vytvořená na jedné regionální verzi Windows se nemusí zobrazit správně na jiné regionální verzi (nebo jiném operačním systému). Pokud k tomu dojde, je nutné specifikovat standard kódování textu (*locale encoding*) manuálně. V českém prostředí se nejčastěji setkáme s encodingem `Windows-1252`, import dat by tedy vypadal následovně:

```{r encoding-example}
#| eval: false
countries <- read_csv("data-raw/countries.csv",
                      locale = locale(encoding = "Windows-1252"))
```

Dalšími populárními verzemi je `Windows-1250`. Pokud žádná z těchto možností nepovede ke správnému importu dat, bůh vám pomáhej. Nebo by mohla pomoct [Wikipedie](https://en.wikipedia.org/wiki/Windows_code_page).
:::

### RDS

Formát `.rds` je specifický pro R. Na rozdíl od `.csv` souborů, `.rds` formát uchovává také metadata, jako je například pořadí kategorií ve faktoru nebo atributy proměnných v dataframu. Tento formát doporučuje používat v rámci práce v R, případně při sdílení dat s kolegy, o kterých víte, že také R používají. Import těchto souborů je velmi podobný importu tomu, co jsme již viděli:

```{r import-rds}
#| eval: false
countries <- read_rds("data-raw/countries.rds")
```

`.rds` soubory nemusí obsahovat pouze jednoduchá tabulková data, ale i složitější objekty, jako jsou listy. Hodí se proto mj. i pro ukládání vytvořených statistických modelů.

### SPSS a Stata

Poměrně velké množství sociálněvědních dat je uloženo ve formátech vlastních SPSS a Stata, jelikož tyto programy dlouhou dobu dominovaly v akademickém prostředí. Základní instalace R neobsahuje funkce, pomocí kterých bychom mohli data v tomto formátu naimportovat, naštěstí ale pro tento účel existuje několik šikovných balíčků. Jedním z nich je balíček `haven`. Pro import dat vytvořených v SPSS:

```{r import-spss}
#| eval: false
countries <- read_spss("data-raw/countries.sav") # funkce z balíčku haven
```

Analogicky, pro import dat ze programu Stata:

```{r import-stata}
#| eval: false
countries <- read_stata("data-raw/countries.dta")
```


::: callout-warning
## Opět encoding

Problém s encodingem vás může potkat i u jiných datových typů než .csv. Manuální pokyn pro to, jaký encoding má R využít, je pro různé "načítací" funkce různý. Pro haven například:

```{r encoding-example2}
#| eval: false
countries <- read_spss("data-raw/countries.sav",
                       encoding = "windows-1250")
```

Pro base R funkci zase: 

```{r encoding-example3}
#| eval: false
countries <- read.csv("data-raw/countries.csv",
                       fileEncoding="windows-1250")
```
:::

Import dat z SPSS provází specifikum dat s "labely". SPSS totiž ukládá data jako číselné hodnoty napojené na označení (angl. labels), co jednotlivé hodnoty reprezentují. Například 1 je "určitě souhlasím", 2 je "spíše souhlasím" atp. Když importujeme data pomocí balíku `haven`, R tuto datovou strukuturu napodobí. Pro práci v R ale není moc vhodná. Mnohem výhodnější je pracovat v R se skutečnými hodnotami proměnných namísto jejich číselných ekvivalentů. Pro tento účel existuje totiž v R vektor typu `faktor`, který byl představen dříve (viz @sec-factors). Nejelegantnějším řešením je data načíst rovnou tak, že všechny proměnné s labely převedem na faktory. To lze přidáním jediné funkce k příkazu pro načtení dat následovně:

```{r import-spss-as-factor}
#| eval: false
countries <- read_spss("data-raw/countries.sav") |> as_factor() # as_factor z balíčku haven
```

### Excel 

Někdy k nám dorazí data ve formátu .xls nebo .xlsx, nativního formátu MS Excel. Pro načtení těchto dat doporučujeme balíček `readxl` a jeho funkce `read_xlsx()` a `read_xls()`:

```{r import-xlsx}
#| eval: false
countries <- read_xlsx("data-raw/countries.xlsx") # funkce z balíčku readxl
```


## Export dat

Export dat probíhá velmi podobně jako jejich import. Zatímco importovací funkce začínají slovesem `read_`, exportovací naopak `write_`. Na rozdíl od čtecích funkcí, které mají jediný povinný argument, a sice cestu k souboru, mají zapisovací funkce dva povinné argumenty: co zapsat a kam to zapsat. Například pro export ve formátu `.csv` do do složky `data-clean` v našem pracovním adresáři:

```{r export-csv}
#| eval: false
write_csv(x = countries, file = "data-clean/countries.csv")
```

Všimněte si, že při exportu dat nepřiřazujeme výsledku funkce žádné jméno, protože nevytváříme nový objekt uvnitř R. Místo toho pomocí argumentu `x` specifikujeme, které objekt chceme exportovat, a pomocí argumentu `file` poté kam a pod jakým jménem. Analogicky bychom mohli využít funkce `write_rds()`, `write_sav()` (pro export do SPSS formátu) a `write_dta()` (pro export od Stata).

Specifickým případem může být zapisování do formátu .xlsx, kde může být užitečné zapisovat do více listů téhož sešitu. K tomu poslouží funkce `write_xlsx()`. Následující příklad ukazuje, jak zapsat na jeden list data pouze pro postsovětské země a na druhý data pouze pro země, které postsovětské nejsou. Trochu při tom předbíháme a používáme funkci `filter()` z balíčku `tidyverse`, se kterou se seznámíme později (viz @sec-radky). Ta ze stejného souboru jednou vytáhne jen ta data, která mají v proměnné `postsoviet` zapsáno "yes", a podruhé jen ta s "no".

```{r export-xlsx}
#| eval: false
write_xlsx(x = list("Postsovětské" = countries |> filter(postsoviet == "yes"),
                    "Ostatní" = countries |> filter(postsoviet == "no")), 
           path = "data-clean/countries.xlsx")
```

::: callout-caution
## Problém s proměnnými typu datum

Pokud si to zkoušíte sami, je možné, že proměnná datum založení `(foundation_date)` se v Excelu nezobrazuje správně. Je to dáno tím, že funkce `read_csv()` i některé další se snaží odhadnout formát dat. Tato proměnná byla nejspíš identifikována jako datum. A tady je problém, protože R a Excel mají odlišný názor na to, jak proměnné typu datum defaultně rozumět. O tom si řekneme více později (viz XXX)
:::

A ještě jedno varování:

::: callout-caution
## Pozor na lomítka

Pokud používáte Windows, dejte si pozor na lomítka v cestách k souborům. R očekává, že budete používat *forward-slash* (`/`), tedy například `project/data-raw/countries.csv`. Naopak Windows používá v cestách *back-slash* (`\`) a cesta by tedy vypadal následovně `project\data-raw\countries.csv`. Při práci v R je nutné používat `/` pokud cestu kopírujete odjinud, je potřeba lomítka ručně opravit. Uživatelé ostatních operačních systémů se patáliemi s lomítky nemusí trápit.
:::

### Rychlejší zapisování cesty pomocí klávesy TAB

Jak už jsme si vysvětlili výše, funkcionalita Projektů RStudia nám velmi pomáhá v tom, že zpravidla zapisujeme jen krátkou relativní cestu k datům. I tak může být někdy otravné muset vypisovat názvy složek a podsložek, ze kterých chceme data načítat nebo do kterých chceme zapisovat, případně si pamatovat, jaké lomítko máme správně použít. Práci nám usnadní funkcionalita RStudia, která spočívá v tom, že když začneme psát cestu k datům uvnitř kterékoliv z funkcí představených v této kapitole, můžeme jednoduše stisknout klávesu `tabulátor` a ukážeme se nám rozbalovací menu, ve kterém můžeme cestu navolit. 
